---
title: Meltdown 攻击
date: 2018-01-05 13:02:37
tags: [Meltdown,技术,安全,翻译,转载]
---
原文地址：[meltdown.pdf](https://meltdownattack.com/meltdown.pdf)
安天翻译地址：[Meltdown攻击[非官方中文速译V0.2版，安天技术公益翻译组译注]](http://bbs.antiy.cn/forum.php?mod=viewthread&tid=77670)
## 译者小序
　　鉴于Meltdown（熔断）漏洞的严重性和漏洞的复杂性足以动摇全球云计算基础设施的根基，为了让管理部门和客户深入了解该漏洞的机理和威胁，安天公益翻译组，在安天微电子与嵌入式安全研发中心和安天安全研究与应急处理中心的支持下，针对披露该漏洞的关键论文“Meltdown”进行了翻译。鉴于文章篇目较长、威胁形势非常紧急，我们通过不足10个小时完成的翻译肯定有很多错误，希望大家予以指出，我们会不断补充完善。
<!-- more -->
### 鸣谢
　　感谢 VMware 解决方案架构师臧铁军连夜协助校对本译文。
# Meltdown攻击
## 摘要
　　计算机系统的安全性从根本上依赖于内存隔离，例如，内核地址范围被标记为不可访问，并且受到访问保护。在这篇文章中，我们将介绍Meltdown攻击。Meltdown利用现代处理器乱序执行的副作用来读取任意内核内存位置，包括个人数据和密码。乱序执行是不可或缺的性能特征，并且存在于各种现代处理器中。该攻击独立于操作系统，并不依赖于任何软件漏洞。Meltdown破坏了地址空间隔离和半虚拟化环境所提供的所有安全假设，从而打破了建立在此基础上的每个安全机制。在受影响的系统上，Meltdown使攻击者可以在没有任何许可或权限的情况下读取同一系统中的其他进程或同一主机上的其它虚拟机的内存，从而影响数百万客户以及几乎所有PC用户。我们证明，KASIS[8]的KAISER防御机制具有阻止Meltdown的重要（歪打正着）副作用。我们强调必须立即部署KAISER，以防止大规模的信息泄露。
## 1 简介
　　内存隔离是当今操作系统的主要安全特征之一。操作系统确保用户应用程序不能访问彼此的内存，并防止用户应用程序读取或写入内核内存。这种隔离是计算环境的基石，允许在个人设备上运行多个应用程序，或者在云中的单台计算机上执行多个用户进程。在现代处理器上，内核和用户进程之间的隔离通常由处理器的一个监视位（supervisor  bit）来实现，该监视位定义内核的内存页面是否可以被访问。其基本思想是，只有在进入内核代码时才能设置该位，切换到用户进程时该位被清除。该硬件特征允许操作系统将内核映射到每个进程的地址空间，并且从用户进程到内核具有非常高效的转换，例如用于中断处理。因此，在实践中，从用户进程切换到内核时不会改变内存映射。在本文中，我们将介绍Meltdown攻击。Meltdown是一种新型的攻击方法，可以完全突破内存隔离，为任何用户程序提供一个简单的方法来读取它在其中执行的机器的整个内核内存，包括映射到内核区域的所有物理内存。Meltdown不利用任何软件漏洞，即它适用于所有主要的操作系统。相反，Meltdown利用了大多数现代处理器（例如2010年后的英特尔微体系结构和其他厂商的其他CPU）上的侧信道信息。
　　侧信道攻击通常需要了解目标应用程序的精确信息，而且是为获取泄漏机密信息量身定做的，但是Meltdown允许能够在存在漏洞的处理器上运行代码的恶意访问者获得整个内核地址空间，包括任何映射的物理内存。Meltdown如此简单而强大的根本原因是乱序执行造成的副作用。
　　乱序执行是当今处理器的一个重要的性能特征，以便克服繁忙的执行单元的延迟，例如，内存读取单元需要等待从内存读取数据。现代处理器并没有延迟执行，而是乱序地执行操作，即它们预见性地将后续操作安排到处理器的空闲执行单元。然而，这样的操作通常会有不必要的副作用，例如，时序差异[28，35，11]可能会泄漏来自顺序执行和乱序执行的信息。
　　从安全角度来看，一个发现特别重要：乱序，存在漏洞的CPU允许非特权进程将数据从特权（内核或物理）地址加载到临时CPU 寄存器中。而且，CPU甚至根据该寄存器值进一步执行计算，例如，根据寄存器值访问数组。如果某个指令不应该被执行，处理器就会通过简单地丢弃内存查找的结果（例如，修改的寄存器状态）来确保正确的程序执行。因此，在体系结构层面（例如，处理器如何执行计算的抽象定义），不会出现安全问题。
　　然而，我们发现乱序内存查找会影响缓存，而缓存又可以通过缓存侧信道进行检测。结果，通过在乱序执行流中读取特权内存，攻击者就能把整个内核内存转储出来，并利用微结构的隐蔽通道在这种微妙的状态下把数据传送到外部。在隐蔽通道的接收端，寄存器值被重构。因此，在微体系结构层面（例如，实际的硬件实现），存在可利用的安全问题。
　　Meltdown打破了CPU的内存隔离能力给出的所有安全假设。我们评估了该攻击对现代台式机和笔记本电脑，以及云中的服务器的影响。Meltdown允许非特权进程读取映射到内核地址空间的数据，包括Linux和OSX的整个物理内存以及Windows的大部分物理内存。这可能包括其他进程和内核的物理内存；在内核共享沙箱解决方案（例如Docker，LXC）、Xen超虚拟模式以及其他共址的情况下，包括内核（或虚拟化管理程序）的内存。虽然性能在很大程度上取决于特定的机器，例如处理器速度，TLB和缓存大小以及DRAM速度，但是我们可以以高达503KB/s的速率转储内核和物理内存。因此，大量的系统受到影响。
　　KAISER[8]最初是为了防止针对KASLR的侧信道攻击，歪打正着地阻止了Meltdown攻击。我们的评估显示，KAISER可以在很大程度上阻止Meltdown攻击。因此，我们强调，立即在所有操作系统上部署KAISER至关重要。幸运的是，三大操作系统（Windows，Linux和OSX）都部署了KAISER变种，并将很快推出补丁。
Meltdown在几个方面与Spectre攻击[19]截然不同，Spectre需要根据受害者进程的软件环境定制攻击，能够更广泛地应用于CPU，而且KAISER无法对其进行缓解。
　　**贡献**。本文的贡献如下：1.我们介绍了一种新的、功能强大的、基于软件的侧信道——乱序执行。2.我们展示了如何将乱序执行与微体系结构隐蔽通道相结合，在这种微妙的状态下把数据传送到外部的接收器。3.我们介绍了将乱序执行与异常处理程序或TSX结合起来的端到端攻击，该攻击能够读取笔记本电脑、台式机和公共云计算机上的任意物理内存，无需任何许可或权限。4.我们评估了Meltdown的性能以及KAISER对它的影响。
　　**大纲**。本文的其余部分结构如下：在第2章中，我们描述了乱序执行导致的基本问题。在第3章中，我们提供了一个示例，说明了Meltdown利用的侧信道。在第4章中，我们描述了整个Meltdown攻击的构建块。在第5章中，我们介绍了Meltdown攻击。在第6章中，我们评估了Meltdown攻击对几种系统的影响。在第7章中，我们讨论了基于软件的KAISER对策的效果，并提出了硬件解决方案。在第8章中，我们讨论相关的工作，并在第9章中总结全文。
## 2背景
　　在本章中，我们介绍乱序执行、地址转换和缓存攻击的背景。
### 2.1乱序执行
　　乱序执行是一种优化技术，它最大限度地利用CPU内核的所有执行单元。CPU不是严格按照顺序执行处理指令的，只要需要的资源可用，就会立即执行它们。当前操作的执行单元被占用时，其他执行单元可以向前排。因此，只要结果遵循架构定义，指令就可以并行运行。
　　在实践中，支持乱序执行的CPU会在弄清楚是否允许之前推测性地执行处理器的乱序逻辑处理指令。在本文中，我们对推测性执行给出一个更具限制性的意思，它指的是分支之后的指令序列，并且使用乱序执行这个术语来指代在处理器已经提交所有先前指令的结果之前执行操作的任何方式。
　　在1967年，Tomasulo[33]开发了一种算法[33]，使指令的动态调度能够实现乱序执行。Tomasulo[33]引入了一个统一的预留站，允许CPU使用已经计算的数据值，而不是将其存储到寄存器并重新读取。预留站重命名寄存器，以允许在相同物理寄存器上运行的指令使用最后一个逻辑寄存器来解决写后读（RAW），读后写（WAR）和写后写（WAW）危险。此外，预留单元通过通用数据总线（CDB）连接所有的执行单元。如果操作数不可用，则预留单元可以在CDB上监听，直到可用，然后直接开始执行该指令。
　　在英特尔架构上，流水线由前端、执行引擎（后端）和内存子系统[14]组成。x86指令由前端从内存中读取并解码为连续发送到执行引擎的微指令（μOP）。乱序执行在执行引擎中执行，如图1所示。重组缓存器负责寄存器分配，寄存器重命名和确认执行。此外，像数据移动消除或清零操作识别等优化可以由重组缓存器直接完成。微指令被转发到统一预留站，将连接到执行单元的出口端口上的操作排队。每个执行单元可以执行不同的任务，如ALU操作、AES操作、地址生成单元（AGU）或内存加载和存储。AGU以及加载和存储执行单元直接连接到内存子系统以处理其请求。
<center>
![图一](https://i.loli.net/2018/01/05/5a4f0f54d6dd3.png)
**图1：简单介绍Intel Skylake微体系结构的一个内核。指令被解码成微指令，并由执行单元乱序执行。**</center>
　　由于CPU通常不运行线性指令流，因此它们具有分支预测单元，用于获得接下来将执行哪条指令的有根据的猜测。分支预测器在实际评估条件之前尝试确定分支的哪个方向。如果预测是正确的，那么在这条路上的指令并没有任何依赖关系可以被提前执行，并立即使用它们的结果。如果预测不正确，重组缓存器允许回滚，即通过清除重组缓存器并重新初始化统一预留站来回滚。
　　预测分支的各种方法：对于静态分支预测[12]，分支的结果完全基于指令本身。动态分支预测[2]在运行时收集统计数据来预测结果。一级分支预测使用1位或2位计数器记录分支的最后结果[21]。现代处理器通常使用两级自适应预测器[36]，记忆最后n个结果的历史记录以定期预测循环模式。最近，有人提出了使用神经分支预测的思想[34，18，32]，并将其整合到CPU架构中[3]。
### 2.2地址空间
　　为了将进程彼此隔离，CPU支持将虚拟地址空间，并负责将虚拟地址转换为物理地址。虚拟地址空间被分成一组页面，可以通过多级页面转换表逐一映射到物理内存。转换表定义了实际的虚拟到物理映射，以及用于强制执行特权检查的保护特性，例如可读、可写、可执行和用户可访问。当前使用的转换表保存在特殊的CPU寄存器中。在每个上下文切换中，操作系统将该寄存器更新为下一个进程的转换表地址，以便实现每个进程的虚拟地址空间。因此，每个进程只能引用属于自己虚拟地址空间的数据。每个虚拟地址空间本身被分割成用户部分和内核部分。
　　虽然用户地址空间可以被正在运行的应用程序访问，但只有当CPU以特权模式运行时才能访问内核地址空间。这是由禁用相应转换表的用户可访问属性的操作系统强制执行的。内核地址空间不仅为内核自己的使用而映射内存，还需要在用户页面上执行操作，例如用数据填充它们。因此，整个物理内存通常映射到内核中。在Linux和OSX系统上，这是通过直接物理映射完成的，即将整个物理内存直接映射到预定义的虚拟地址（参见图2）。
<center>
![图2](https://i.loli.net/2018/01/05/5a4f118278e57.png)
**图2：物理内存以一定的偏移量直接映射到内核中。用户空间可访问的物理地址（蓝色）也直接映射到内核空间。**
</center>
　　Windows不使用直接物理映射，而是维护多个所谓的分页池、非分页池和系统缓存。这些池是内核地址空间中的虚拟内存区域，将物理页面映射到虚拟地址，或者保留在内存中（非分页池），或者可以从内存中移除，因为副本已经存储在磁盘上（分页池）。系统缓存还包含所有文件支持页面的映射。结合起来，这些内存池通常会将大部分物理内存映射到每个进程的内核地址空间。
　　内存损坏漏洞的利用通常需要了解特定数据的地址。为了阻止这种攻击，引入了地址空间布局随机化（ASLR）以及非可执行堆栈和stack  canaries。为了保护内核，KASLR随机化每次启动时驱动程序所在位置的偏移量，使得攻击变得更加困难，因为攻击者需要猜测内核数据结构的位置。但是，侧信道攻击可以检测到内核数据结构的确切位置[9，13，17]，或者在Java Script中对ASLR进行去随机化[6]。软件漏洞和这些地址的知识的组合可以导致特权代码的执行。
### 2.3缓存攻击
为了加速内存访问和地址转换，CPU包含一些称为缓存的小内存缓冲区，用于存储常用数据。CPU缓存通过在较小和较快的内部内存中缓存常用数据来隐藏慢速内存访问延迟。现代CPU具有多个级别的缓存，这些缓存或者是其内核专用的，或者是在它们之间共享的。地址空间转换表也存储在内存中，也被缓存在常规缓存中。
缓存侧信道攻击利用缓存引入的时序差异。之前，研究人员已经提出并演示了不同的缓存攻击技术，包括Evict + Time [28]，Prime + Probe [28,29]和Flush + Reload [35]。Flush+Reload（刷新+重新加载）攻击的颗粒度可以达到单个缓存线级别。这些攻击利用共享的最后一级缓存。攻击者经常使用clflush指令刷新目标内存位置。通过测量重新加载数据所需的时间，攻击者可以确定数据是否由另一个进程同时加载到缓存中。Flush+Reload攻击已被用于各种计算的攻击，例如加密算法[35，16，1]，Web服务器函数调用[37]，用户输入[11，23，31]和内核寻址信息[9]。
一个特殊用例是隐蔽通道。在这里，攻击者控制导致副作用的部分和测量副作用的部分。这可以用来将信息从一个安全域泄漏到另一个安全域，同时绕过架构层或以上的任何边界。Prime+Probe和Flush+Reload都被用于高性能的隐蔽通道[24，26，10]。
## 后略
论文较长，剩余内容可以参见PDF文件。



