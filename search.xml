<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[续·终物语]]></title>
    <url>%2F2019%2F04%2F08%2FZokuOwarimonogatari%2F</url>
    <content type="text"><![CDATA[什么嘛 这种事情而已如果不知道前行时是先迈出右脚还是左脚的话这样做不就行了吗 不是像袋鼠 而是像青蛙一样我在原田径部部员强韧的脚力牵引下为了不至于被抛下而紧跟上去向前进发增添了两成之后向前进发向着光芒的方向跳跃 前一天晚上看完了续·终物语，今天写这篇文章时，迟迟无法下笔，不知道该怎么写。我突然联想到了四叠半神话大系，两部作品都在结尾点题。刚刚去豆瓣看了一下，现在四叠半在豆瓣电影9分，续终物语8.8分，这足够说明这两部作品的优秀。四叠半重点在于不同的选择，而续重点在于放下曾经的遗憾。就本质上来说，四叠半男主不同的选择，都是为了过上玫瑰色的校园生活，最后的结尾，走出四叠半，面对现实，在这一方面和续不谋而合。 我虽然没有写过一篇关于四叠半的文章，但四叠半在我心中的地位是不可动摇的。目前，我最喜欢的日本动漫里就有四叠半和物语系列，而且他们在很高的位置上。今天我写了这篇关于续·终物语的文章，主要还是因为它和我现在情况非常吻合，对我现在有非常大的启示作用。虽然我刚上大学时并不看动漫，更不用说看四叠半神话大系，但四叠半会一直影响着我，包括即将到来的研究生生活。 很多人问过我，为什么要读研。我只有一个回答：“我太菜了，还是想多学点”。这是实话，可能很多人读研是为了找工作，而我不是，甚至我还想读博。上高中时我就接触学习了计算机和安全相关的知识，当时觉得自己好牛逼，什么都会，周围人全是辣鸡，非常膨胀，因为比别人懂更多的知识，就有点飘飘然了。高考时没考好，考了一个计算机好点的普通一本。不过上了大学，学的知识多了，越发现了自己的不足，其实自己什么都不懂。虽然可能在周围的同学和别人看来，我的确是他们口中的大神，他们的问题我也可以解决。但是我同时见到了在其他地方有更多比我更厉害的人。对比那些少年成才，就算晚了些，也有在大学期间可以日穿各大公司内网，CVE一大堆的大佬，而我和他们相比差距太多了。我想学到更多的东西，也想成为那些真正的大佬，所以选择了继续学习，至于工作，我想如果学到了东西，是不会愁的。 在四叠半中，男主是一个犹豫不决的人，想过上玫瑰色的校园生活，在各个平行世界中不断的做出不同的选择，但最终却什么都没有，并没有过上想象中的生活。而在最后，被困于四叠半的男主，观察到了不同平行世界的自己，以为他们都过这玫瑰色的生活，然而事实却不是这样。最后他冲出四叠半，面向现实，迈出了那一步。就像樋口师傅所说，根本没有玫瑰色的生活。那位算命的老人也在不停的说，良机就在眼前。而男主却总是忽略了眼前的机会，一直裹步不前，总想着换一种选择也许会更好。最后男主认识到了这一切，走出封闭自己的四叠半空间，冲出牢笼，把小熊还给了明石，约她吃猫拉面，找到了自己的黑发少女。 阿良良木历在物语的故事里解决了各种怪异，大多数结果都是比较好的，但是也充满了遗憾。在续终物语中，虽然想继续前进，但由于对过去遗憾的不舍，经历了反转世界。在那个世界里，没有拯救八九寺失败的遗憾，八九寺成功长大、老仓育也没有遗憾，和阿良良木历一起快乐的生活、忍也不是吸血鬼等等。当扇和斧乃木提起，待在这个世界，被这个世界同化，虽然阿良良木历有所犹豫，但都拒绝了。最后和扇的对话，他终于认识到了这一切。并不是他被拉到了镜中，而是他把镜中的世界拉到了现实，表里反转，而这一切的原因就是因为他的犹豫，他对过去遗憾的不舍，无法前进。 续·终物语最后的结尾，被垃圾君和荡漾喂了满口狗粮 只要是与你有关的事情 我就没有留下过遗憾 不过，最后的那部分对话也是点睛升华之笔，也是我想要写这篇文章的原因。我把最后那部分阿良良木历的自述和与战场原的对话全部敲了下来，放到了文章的最后。 就正如没有玫瑰色的校园生活一样，研究生生活也不会是玫瑰色，做出选择就应该一路走下去，不能因为过去的遗憾而后悔迟疑。就正如我现在所面对的一样。充满了遗憾，但也做出了选择，或许可能选择另一条没有遗憾的路可能也不错，但是已经做了选择。犹豫的时候就像续终物语最后阿良良木历面对红绿灯说出的那些话 虽然是很偶然的事情不过从以前开始我在人行横道像这样等红绿灯的时候信号变为绿色的时候我曾经搞不清应当先迈出哪一只脚呢第一步该是右脚呢还是该迈左脚呢或者干脆像迷信一般决定好迈哪只脚好了 一经思考便会迷茫即便头脑中明白必须要前进但双脚却不听使唤就像全身僵住了一般即便知道命运不会因为这种事情而改变即便如此 也会变的迷茫不知方向不是留下心 而是将身体留在了原地 听到阿良良木历说的话，战场原笑了起来，笑的非常厉害，随着一句『这样做不就行了吗』，拉着阿良良木的手一跃而出，阿良良木也为了不被抛下紧跟上去，向着下一个物语起身一跃。 我现在也站在了红绿灯路口，同样面对了要迈出哪只脚的问题。另一方面，我也被四叠半空间所困。走上这条路，做出这个选择，将来要面临的主要只有两个问题，一个是学英语和日语，走学校项目赴日，二就是读博，双线并行，压力更大。而阻拦在这面前的就是我的惰性。我一直知道，我是一个非常懒的人，如果不走出这四叠半的空间，我可能一辈子被其所困。我不想这样，我想做出改变。不仅仅是阿良良木历的续·终物语，也是我的续·终物语。 唤起回忆，放下遗憾，留出余韵和余白。我们向着下一个物语，起身一跃。 我在疑似的『镜中的国度』中经历的哪一件事才是我的遗憾呢又或者说我有许多个遗憾那一切既是她们的遗憾同时也是我自身的遗憾小扇这么说过既是她们的那20% 亦是我的那20%那份被遗弃的丢失的心情或许是想为过去嘲笑火怜穿裙子的事情道歉后悔过去曾经让斧乃木攻击手折正弦而这份后悔或许并没有因为她是人偶而消散没能挽救八九寺将她供奉为神的事情在我还上学的时候没能解决神原左手的问题没能更早的挽救老仓千石的事情更不必说了还有将忍束缚到影子里的事情一年级三班···还有诸多其他事情遗憾的事情堆积如山实在是难以说我怀着轻松舒畅的心情毕业了实际上也不能说是了却了一切遗憾吧不过是回想起来 面对了一切而已大概 这也就足够了吧我无法背负起一切 也不能带着一切前行不过···偶尔回忆起也无妨吧 不过不知道的话 还是很令人在意呢历的遗憾究竟是哪一个呢大家认识出现偏移的阿良良木历形象或许是提示理想的阿良良木历和镜像的阿良良木历我说着玩的 有一件事是确定的只要是与你有关的事情我就没有留下过遗憾因为接下来我们也要一直在一起 还是等成绩发表了之后再说吧要是你落榜了 我们可就四散分离了 虽然是很偶然的事情不过从以前开始我在人行横道像这样等红绿灯的时候信号变为绿色的时候我曾经搞不清应当先迈出哪一只脚呢第一步该是右脚呢还是该迈左脚呢或者干脆像迷信一般决定好迈哪只脚好了 一经思考便会迷茫即便头脑中明白必须要前进但双脚却不听使唤就像全身僵住了一般即便知道命运不会因为这种事情而改变即便如此 也会变的迷茫不知方向不是留下心 而是将身体留在了原地 什么嘛 这种事情而已如果不知道前行时是先迈出右脚还是左脚的话这样做不就行了吗 不是像袋鼠 而是像青蛙一样我在原田径部部员强韧的脚力牵引下为了不至于被抛下而紧跟上去向前进发增添了两成之后向前进发向着光芒的方向跳跃 结束了延续至今的物语唤起回忆 放下遗憾留出余韵和余白 我们向着下一个物语起身一跃]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Delete]]></title>
    <url>%2F2019%2F01%2F06%2Fnew-2019%2F</url>
    <content type="text"><![CDATA[9102年了，看了看以前写的辣鸡文章，想删网站跑路了。想了想，还是没有，删了几篇太蠢的文章…… 想想看自己还是太菜了，越学习越发现自己越菜，连个洞也挖不出来。只求过几个月考研成绩出来可以成功上岸吧~ 成绩出来了，并不理想，顶着压力勉强上岸了。面前只有两条路，出国，读博，或者二合一。总之，硕士期间学习压力可以想象到有多大。 换了电脑以后对blog进行了整体迁移。因为考虑到旧的Next到现在也有很长时间了，就直接用的最新的系统，一次比较彻底的升级，改动很大，不过大多数地方和以前也区别不大。 接下来的一年，只能更努力的学习了。]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF中常见的RSA相关问题总结[转]]]></title>
    <url>%2F2018%2F07%2F21%2FRSA-ATTACK%2F</url>
    <content type="text"><![CDATA[原文:CTF中常见的RSA相关问题总结前言理解基本概念后，代码就可以说明一切，所以本文将每种攻击方式的实现方法都提炼成了一个函数，在理解原理时会有帮助，在需要时也可以直接调用。 基础RSA概要在开始前可以通过 《RSA算法详解》 这篇文章了解关于RSA的基础知识，包括加解密方法，算法原理和可行性证明等。 应用流程 选取两个较大的互不相等的质数p和q，计算n = p * q 。 计算phi = (p-1) * (q-1) 。 选取任意e，使得e满足 1&lt;e&lt;phi 且 gcd(e , phi) == 1 。 计算e关于n的模逆元d， 即d满足(e * d)% n ==1 。 加解密：c = (m ^ e) % n ， m = (c ^ d) % n 。其中m为明文，c为密文，(n,e)为公钥对，d为私钥，要求 0 &lt;= m &lt; n 。 理解模逆运算 如果(a*b)%c==1 ，那么a和b互为对方模c的模逆元/数论倒数，也写作 。 关于最大公约数有一个基本事实：给予两整数a、c，必存在整数x、y使得ax + cy = gcd(a,c) ，基于这个事实，当a,c互素即gcd(a,c)==1 时，有ax+cy=1 ，那么就有(a*x)%c==1 ，所以x就是a 对c的模逆元。因此，a对c存在模逆元b的充要条件是gcd(a,c)==1 。显然对于每一组a,c ，存在一族满足条件的x，在求模逆元时我们取得是最小正整数解x mod n 。 上述的基本事实很容易理解，因为a和c的最大公约数是gcd(a,b)，所以a和c都可表示为gcd(a,b)的整数倍，那么a和b的任意整系数的线性组合ax+by也必定能表示成gcd(a,c)的整数倍，他们当中最小的正整数就应该是gcd(a,c)。实际上最大公约数有一个定义就是：a和b的最大公约数g是a和b的线性和中的最小正整数 。 求模逆元主要基于扩展欧几里得算法，贴一个Python实现： 123456789 def egcd ( a , b ): if (b == 0): return 1, 0, a else: x , y , q = egcd( b , a % b ) # q = GCD(a, b) = GCD(b, a%b) x , y = y, ( x - (a // b) * y ) return x, y, q def mod_inv(a,b): return egcd(a,b)[0]%b #求a模b得逆元 求模逆也可直接利用gmpy2库。如 import gmpy2;print gmpy2.invert(47,30) 可求得47模30的逆为23。模意义下的运算法则 1234567891011121314151617181920(a + b) % n ≡ (a % n + b % n) % n(a - b) % n ≡ (a % n - b % n) % n(a * b) % n ≡ (a % n * b % n) % n(a ^ b) % n ≡ ((a % n) ^ b) % n //幂运算若 a ≡ b(mod n) ,则1.对于任意正整数c,有a^c ≡ b^c(mod n)2.对于任意整数c,有ac ≡ bc(mod n),a+c ≡ b+c(mod n),3.若 c ≡ d(mod n),则a-c ≡ b-d(mod n),a+c ≡ b+d(mod n),ac ≡ bd(mod n)如果ac≡bc (mod m)，且c和m互质，则a≡b (mod m）。[理解：当且仅当c和m互质,c^-1存在,等式左右可同乘模逆。]除法规则：在模n意义下，a/b不再仅仅代表这两个数相除，而是指 a+k1*n 和 b+k2*n这两个组数中任意两个相除，使商为整数因此也就可以理解，除以一个数等价于乘以它的逆a/b ≡ c(mod n) &lt;=&gt; a ≡ c*(b^-1) (mod n)，其中b模n的逆记作b的负一次方。费马小定理:a是整数,p是质数,则a^p==a(mod p),如果a不是p的倍数,还有a^(p-1) ≡ 1(mod p) 推荐文章 模运算总结 和 取模运算涉及的算法 。 欧几里得算法欧几里得算法是求最大公约数的算法, 也就是中学学的 辗转相除法 。记 gcd(a,b) 为a和b的最大公约数，欧几里得算法的基本原理是gcd(a,b)==gcd(b,a%b),(b!=0) 和 gcd(a,0)==a 。 Python实现如下： 123456789# 递归版def gcd(a, b): return a if not b else gcd(b, a % b)# 迭代版def gcd2(a, b): while b: a, b = b, a % b return a 扩展欧几里得算法扩展欧几里得算法基于欧几里得算法，能够求出使得 ax+by=gcd(a,b) 的一组x,y。 这篇文章 解释得很到位，对照下图和以下递归版实现容易理解。 Python实现如下： 12345678910111213141516171819202122232425# 递归版def ext_euclid ( a , b ): # ref:https://zh.wikipedia.org/wiki/扩展欧几里得算法 if (b == 0): return 1, 0, a else: x1 , y1 , q = ext_euclid( b , a % b ) # q = GCD(a, b) = GCD(b, a%b) x , y = y1, ( x1 - (a // b) * y1 ) return x, y, q# 迭代版def egcd(a, b): # ref:https://blog.csdn.net/wyf12138/article/details/60476773 if b == 0: return (1, 0, a) x, y = 0, 1 s1, s2 = 1, 0 r, q = a % b, a / b while r: m, n = x, y x = s1 - x * q y = s2 - y * q s1, s2 = m, n a, b = b, r r, q = a % b, a / b return (x, y, b) 中国剩余定理维基百科 给出了简洁生动的说明: 参考以上说明进行的Python实现: 1234567891011def CRT(mi, ai): # mi,ai分别表示模数和取模后的值,都为列表结构 # Chinese Remainder Theorem # lcm=lambda x , y:x*y/gcd(x,y) # mul=lambda x , y:x*y # assert(reduce(mul,mi)==reduce(lcm,mi)) # 以上可用于保证mi两两互质 assert (isinstance(mi, list) and isinstance(ai, list)) M = reduce(lambda x, y: x * y, mi) ai_ti_Mi = [a * (M / m) * gmpy2.invert(M / m, m) for (m, a) in zip(mi, ai)] return reduce(lambda x, y: x + y, ai_ti_Mi) % M 以上程序将mi当作两两互质处理,实际上有时会遇到其他情况，这时就需要逐一两两合并方程组。我参照下图实现了一个互质与不互质两种情况下都能工作良好的中国剩余定理（解同余方程组）的Python程序。 12345678910111213def GCRT(mi, ai): # mi,ai分别表示模数和取模后的值,都为列表结构 assert (isinstance(mi, list) and isinstance(ai, list)) curm, cura = mi[0], ai[0] for (m, a) in zip(mi[1:], ai[1:]): d = gmpy2.gcd(curm, m) c = a - cura assert (c % d == 0) #不成立则不存在解 K = c / d * gmpy2.invert(curm / d, m / d) cura += curm * K curm = curm * m / d cura %= curm return (cura % curm, curm) #(解,最小公倍数) 图片截自 中国剩余定理（互质与不互质的情况） 。 常见攻击方式实践准备工具 python gmpy2库 Windows：可从https://pypi.org/project/gmpy2/#files 直接下载已编译的安装包。 Linux： sudo apt install python-gmpy2 libnum库： git clone https://github.com/hellman/libnum.git &amp;&amp; cd libnum &amp;&amp; python setup.py install yafu https://sourceforge.net/projects/yafu/ RSATool2v17.exe RSA解密若已知私钥d，则可以直接解密： m=pow(c,d,n) 。 若已知质数p和q，则通过依次计算欧拉函数值phi、私钥d可解密。简易实现如下： 123456789def rsa_decrypt(e, c, p, q): phi = (p - 1) * (q - 1) n = p * q try: d = gmpy2.invert(e, phi) #求e模phi的逆 return pow(c, d, n) except Exception as e: print "e and phi are not coprime!" raise e 在选取加密指数e时要求phi，e互质，也就是gcd(phi,e)==1 ，如果不满足是无法直接解密的。 为什么说这个呢？是因为有时会有乍一看有点奇怪的情况。比如SCTF2018的Crypto - a number problem ，题目是 12x**33=1926041757553905692219721422025224638913707 mod 3436415358139016629092568198745009225773259tell me the smallest answer of x 其中n=3436415358139016629092568198745009225773259 可以直接分解得到p,q，出phi=(p-1)*(q-1) ，然后惊奇地发现gcd(phi,33)==3 。这时如果对加密过程比较熟悉的话，就可以想到实际上公钥e=11 ，明文是m=x^3 ，应该先求出m。然后再爆破x。 123456for i in range(1000000): # 推荐使用gmpy2库运算，用pow开立方不可行 if gmpy2.iroot(m + i * n, 3)[1]: x = gmpy2.iroot(m + i * n, 3)[0] # i==243277,x==9420391510958023 break 查询已知的n的可分解情况在线查询：https://factordb.com/ api接口： 123curl http://factordb.com/api?query=12345response:&#123;"id":"12345","status":"FF","factors":[["3",1],["5",1],["823",1]]&#125; 使用yafu分解N适用情况：p,q相差较大或较小时可快速分解。 使用方法：yafu-x64.exe factor(233) ，yafu-x64.exe help 模不互素 （gcd(N1,N2)!=1）适用情况：存在两个或更多模数 ，且gcd(N1,N2)!=1 。 多个模数n共用质数，则可以很容易利用欧几里得算法求得他们的质因数之一gcd(N1,N2) ，然后这个最大公约数可用于分解模数分别得到对应的p和q，即可进行解密。实现参照本文欧几里得算法 部分和RSA解密 部分。 共模攻击适用情况：明文m、模数n相同，公钥指数e、密文c不同，gcd(e1,e2)==1 对同一明文的多次加密使用相同的模数和不同的公钥指数可能导致共模攻击。简单证明见代码注释。 Python实现： 123456789101112def common_modulus(n, e1, e2, c1, c2): """ ref: https://crypto.stackexchange.com/questions/16283/how-to-use-common-modulus-attack ∵gcd(e1,e2)==1,∴由扩展欧几里得算法，存在e1*s1+e2*s2==1 ∴m==m^1==m^(e1*s1+e2*s2)==((m^e1)^s1)*((m^e2)^s2)==(c1^s1)*(c2^s2) """ assert (libnum.gcd(e1, e2) == 1) _, s1, s2 = gmpy2.gcdext(e1, e2) # 若s1&lt;0，则c1^s1==(c1^-1)^(-s1)，其中c1^-1为c1模n的逆元。 m = pow(c1, s1, n) if s1 &gt; 0 else pow(gmpy2.invert(c1, n), -s1, n) m *= pow(c2, s2, n) if s2 &gt; 0 else pow(gmpy2.invert(c2, n), -s2, n) return m % n 例子：QCTF2018-XMan选拔赛 / Xman-RSA 【共模攻击+模不互素】这道题利用了共模攻击和模不互素。刚开始是一个字符替换，与本文无关。encryption.encrypted文件被做了字符替换，根据语法确定替换表，修复文件得到源文件如下。 题目附件见文末链接。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from gmpy2 import is_primefrom os import urandomimport base64def bytes_to_num(b): return int(b.encode('hex'), 16)def num_to_bytes(n): b = hex(n)[2:-1] b = '0' + b if len(b) % 2 == 1 else b return b.decode('hex')def get_a_prime(l): random_seed = urandom(l) num = bytes_to_num(random_seed) while True: if is_prime(num): break num += 1 return numdef encrypt(s, e, n): p = bytes_to_num(s) p = pow(p, e, n) return num_to_bytes(p).encode('hex')def separate(n): p = n % 4 t = (p * p) % 4 return t == 1f = open('flag.txt', 'r')flag = f.read()msg1 = ""msg2 = ""for i in range(len(flag)): if separate(i): msg2 += flag[i] else: msg1 += flag[i]p1 = get_a_prime(128)p2 = get_a_prime(128)p3 = get_a_prime(128)n1 = p1 * p2n2 = p1 * p3e = 0x1001c1 = encrypt(msg1, e, n1)c2 = encrypt(msg2, e, n2)print(c1)print(c2)e1 = 0x1001e2 = 0x101p4 = get_a_prime(128)p5 = get_a_prime(128)n3 = p4 * p5c1 = num_to_bytes(pow(n1, e1, n3)).encode('hex')c2 = num_to_bytes(pow(n1, e2, n3)).encode('hex')print(c1)print(c2)print(base64.b64encode(num_to_bytes(n2)))print(base64.b64encode(num_to_bytes(n3))) n2，n3已知，利用共模攻击得到n1，由gcd(n1,n2)==p1 分解n1，n2，就可解密得到两部分msg，拼接即可。 解题脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding: utf-8 -*-# by https://findneo.github.io/import base64import libnumimport gmpy2def fix_py(): # decode encryption.encrypted s1 = 'abdefghijklmpqrtuvwxyz' s2 = 'dmenwfoxgpyhirasbktclu' f1 = open('encryption.encrypted') with open('encryption.py', 'w') as f2: for i in f1.readlines(): tmp = '' for j in i: tmp += s2[s1.index(j)] if j in s1 else j f2.write(tmp)# fix_py()def common_modulus(n, e1, e2, c1, c2): assert (libnum.gcd(e1, e2) == 1) _, s1, s2 = gmpy2.gcdext(e1, e2) m = pow(c1, s1, n) if s1 &gt; 0 else pow(gmpy2.invert(c1, n), -s1, n) m *= pow(c2, s2, n) if s2 &gt; 0 else pow(gmpy2.invert(c2, n), -s2, n) m %= n return m[n2, n3] = map(lambda x: int(base64.b64decode(x).encode('hex'), 16), open('n2&amp;n3').readlines())[n1c1, n1c2] = map(lambda x: int(x, 16), open('n1.encrypted').readlines())[msg1c1, msg2c2] = map(lambda x: int(x, 16), open('ciphertext').readlines())# 通过共模攻击得到n1e1 = 0x1001e2 = 0x101n1 = common_modulus(n3, e1, e2, n1c1, n1c2)# n1,n2有一个共有质因数p1# n1 += n3 # 存在n3比n1小的可能，并且确实如此;貌似主办方中途改题，把n1改成小于n3了。p1 = gmpy2.gcd(n1, n2)assert (p1 != 1)p2 = n1 / p1p3 = n2 / p1e = 0x1001d1 = gmpy2.invert(e, (p1 - 1) * (p2 - 1))d2 = gmpy2.invert(e, (p1 - 1) * (p3 - 1))msg1 = pow(msg1c1, d1, n1)msg2 = pow(msg2c2, d2, n2)msg1 = hex(msg1)[2:].decode('hex')msg2 = hex(msg2)[2:].decode('hex')print msg1, msg2# XA&#123;RP0I_0Itrsigi s.y# MNCYT_55_neetnvmrap&#125;# XMAN&#123;CRYPT0_I5_50_Interestingvim rsa.py&#125; 小明文攻击适用情况：e较小，一般为3。 公钥e很小，明文m也不大的话，于是m^e=k*n+m 中的的k值很小甚至为0，爆破k或直接开三次方即可。 Python实现： 123456def small_msg(e, n, c): print time.asctime(), "Let's waiting..." for k in xrange(200000000): if gmpy2.iroot(c + n * k, e)[1] == 1: print time.asctime(), "...done!" return gmpy2.iroot(c + n * k, 3)[0] 例子：Extremely hard RSA题目提供的n是4096位的，e=3。 12345678910111213import gmpy2,binascii,libnum,timen=0xB0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929e=3res=0c=int(open('extremelyhardRSA.rar/flag.enc','rb').read().encode('hex'),16)print time.asctime()for i in xrange(200000000): if gmpy2.iroot(c+n*i,3)[1]==1: res=gmpy2.iroot(c+n*i,3)[0] print i,res print libnum.n2s(res) print time.asctime() break Rabin加密中的N可被分解适用情况：e==2 Rabin加密是RSA的衍生算法，e==2是Rabin加密典型特征，可以百度或阅读 https://en.wikipedia.org/wiki/Rabin_cryptosystem 以了解到详细的说明，这里只关注解密方法。一般先通过其他方法分解得到p，q，然后解密。 Python实现： 1234567891011def rabin_decrypt(c, p, q, e=2): n = p * q mp = pow(c, (p + 1) / 4, p) mq = pow(c, (q + 1) / 4, q) yp = gmpy2.invert(p, q) yq = gmpy2.invert(q, p) r = (yp * p * mq + yq * q * mp) % n rr = n - r s = (yp * p * mq - yq * q * mp) % n ss = n - s return (r, rr, s, ss) 函数返回四个数，这其中只有一个是我们想要的明文，需要通过其他方式验证，当然CTF中显然就是flag字眼了。 解密方法是参照维基百科的，截图如下： 例子：Jarvis OJ hard RSA解题脚本 123456789101112131415161718import gmpy2,libnumn=0xC2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDp=275127860351348928173285174381581152299q=319576316814478949870590164193048041239e=2c=int(open('hardRSA.rar/flag.enc','rb').read().encode('hex'),16)mp=pow(c,(p+1)/4,p)mq=pow(c,(q+1)/4,q)yp=gmpy2.invert(p,q)yq=gmpy2.invert(q,p)r=(yp*p*mq+yq*q*mp)%nrr=n-rs=(yp*p*mq-yq*q*mp)%nss=n-sprint libnum.n2s(r)print libnum.n2s(rr)print libnum.n2s(s)print libnum.n2s(ss) Wiener’s Attack 适用情况：e过大或过小。 工具：https://github.com/pablocelayes/rsa-wiener-attack 在e过大或过小的情况下，可使用算法从e中快速推断出d的值。详细的算法原理可以阅读：低解密指数攻击 。 123456789101112131415161718from Crypto.PublicKey import RSAimport ContinuedFractions, Arithmeticdef wiener_hack(e, n): # firstly git clone https://github.com/pablocelayes/rsa-wiener-attack.git ! frac = ContinuedFractions.rational_to_contfrac(e, n) convergents = ContinuedFractions.convergents_from_contfrac(frac) for (k, d) in convergents: if k != 0 and (e * d - 1) % k == 0: phi = (e * d - 1) // k s = n - phi + 1 discr = s * s - 4 * n if (discr &gt;= 0): t = Arithmetic.is_perfect_square(discr) if t != -1 and (s + t) % 2 == 0: print("Hacked!") return d return False 例子：2018强网杯nextrsa-Level21234n = 0x92411fa0c93c1b27f89e436d8c4698bcf554938396803a5b62bd10c9bfcbf85a483bd87bb2d6a8dc00c32d8a7caf30d8899d90cb8f5838cae95f7ff5358847db1244006c140edfcc36adbdcaa16cd27432b4d50d2348b5c15c209364d7914ef50425e4c3da07612cc34e9b93b98d394b43f3eb0a5a806c70f06697b6189606eb9707104a7b6ff059011bac957e2aae9ec406a4ff8f8062400d2312a207a9e018f4b4e961c943dfc410a26828d2e88b24e4100162228a5bbf0824cf2f1c8e7b915efa385efeb505a9746e5d19967766618007ddf0d99525e9a41997217484d64c6a879d762098b9807bee46a219be76941b9ff31465463981e230eecec69691d1Le = 0x6f6b385dd0f06043c20a7d8e5920802265e1baab9d692e7c20b69391cc5635dbcaae59726ec5882f168b3a292bd52c976533d3ad498b7f561c3dc01a76597e47cfe60614f247551b3dbe200e2196eaa001a1d183886eeacddfe82d80b38aea24de1a337177683ed802942827ce4d28e20efef92f38f1b1a18c66f9b45f5148cceabfd736de8ac4a49e63a8d35a83b664f9f3b00f822b6f11ff13257ee6e0c00ca5c98e661ea594a9e66f2bd56b33d9a13f5c997e67a37fcf9a0c7f04d119fe1ba261127357e64a4b069aefed3049c1c1fe4f964fd078b88bedd064abea385cfebd65e563f93c12d34eb6426e8aa321033cfd8fe8855b9e74d07fe4f9d70de46fLd = wiener_hack(e, n)print d #42043 私钥文件修复适用情况：提供破损的私钥文件。 例子：Jarvis OJ-God Like RSA参考 https://www.40huo.cn/blog/rsa-private-key-recovery-and-oaep.html 修复存储私钥的文件，得到p和q。 1234567891011121314151617import gmpy2,binascii,libnum,timefrom Crypto.PublicKey import RSAwith open('godlikeRSA.rar/pubkey.pem', 'r') as f: key = RSA.importKey(f) n = key.n e = key.ep = 30061432003658510087798871614869318011389940352798147030129806359975911392091235344042288409629143229311060231549478211871643725394470760528211801310601767727834886942210718412087541234398453046895030858579989874035849439867334906873642352112428914855967993998732685221108379784833027771293275558876952608462050146340591449046825135890871650866799299533696175818103240024841274114925018619060818213433528894936128306780366785977567327073724428211445259983614467640785163297734447975723664659822673456683284394386723716344090232882990461174301609971805075768328757325956784604364401827152431260896927633163074694121679q = 26136662545551829820746942051638228325025130519175536694008242208616774469870765684858288042819063837180243501117310278632509413217676559484513481677689042623348188876598901642459170232360966754692434316796014314498263800234390539118817050074978421973817764644287745302885861277447227180288605200894138168586207384484170481511828680117688324729381172912436910052489279406590356734739774635376711681212908417321705094537960645308009611045658947359297373154395500467689532455017647450616447445444254910371922944620114234547655209970657063715028350418518417105772707885648587233103869340985670430269862943630137067052883print n==p*qphi=(p-1)*(q-1)d=gmpy2.invert(e,phi)print e*d%phic=int(open('godlikeRSA.rar/flag.enc','rb').read().encode('hex'),16)m=pow(c,d,n)print m# 1370223550024951160390505387130177939237950112048472397389773634788136940247048803373180904499220116137720016277614401463947529601059601275191225565163007356175594695217230371190488219356030961008234353281422568670237109241798409859772276203338663213736672988507101836099731545753186306605979236795416523018072994981230167509019379957053839561135207769133885837247551721998502691458955042383536845772871317832519566606644011038158531192089650858814552702073939336587081668849526410118259284356539710136294431275218448114094635426857980426460905608258535404240097392254948848433684475139365021846569436926295331904560877283857331146381104141185386272078892946248648795223866902960499271054375730866146508724739787771837579817109380817612386428775429383894697178101165350212843220568133053034913426083965937819287414427916848075303046293039426388342757953620799736182799948741710617974079729792088434776370340095313622264898772452440870247810948774919910578850614282925852564445288646487485017449052934955175051072066751519784123645584671119185023928739438748519535869994754998423784897445884244844154563303115861175492133906368196005147361767160830004522010287149025190543608485818909441439294996482797249312140402141744752129890112# 明文是这个，flag是啥不知道 LSB Oracle Attack适用情况：可以选择密文并泄露最低位。 在一次RSA加密中，明文为m，模数为n，加密指数为e，密文为c。我们可以构造出c&#39;=((2^e)*c)%n=((2^e)*(m^e))%n=((2*m)^e)%n ， 因为m的两倍可能大于n，所以经过解密得到的明文是 m&#39;=(2*m)%n 。我们还能够知道 m&#39; 的最低位lsb 是1还是0。 因为n是奇数，而2*m 是偶数，所以如果lsb 是0，说明(2*m)%n 是偶数，没有超过n，即m&lt;n/2.0 ，反之则m&gt;n/2.0 。举个例子就能明白2%3=2 是偶数，而4%3=1 是奇数。以此类推，构造密文c&quot;=(4^e)*c)%n 使其解密后为m&quot;=(4*m)%n ，判断m&quot; 的奇偶性可以知道m 和 n/4 的大小关系。所以我们就有了一个二分算法，可以在对数时间内将m的范围逼近到一个足够狭窄的空间。 更多信息可参考：RSA Least-Significant-Bit Oracle Attack 和 RSA least significant bit oracle attack 。 Python实现： 123456789101112131415161718import decimaldef oracle(): return lsb == 'odd'def partial(c, e, n): k = n.bit_length() decimal.getcontext().prec = k # for 'precise enough' floats lo = decimal.Decimal(0) hi = decimal.Decimal(n) for i in range(k): if not oracle(c): hi = (lo + hi) / 2 else: lo = (lo + hi) / 2 c = (c * pow(2, e, n)) % n # print i, int(hi - lo) return int(hi) 例子：QCTF2018-XMan选拔赛/Baby RSA题目如下 1234567891011e = 0x10001n = 0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716dbc = 0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0λ nc 47.96.239.28 23333----------------------------- baby rsa -----------------------------Come and Decode your dataIf you give me ciphertext, I can tell you whether decoded data is even or oddYou can input ciphertext(hexdecimal) now1odd 解题脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# -*- coding: utf-8 -*-# by https://findneo.github.io/# ref:# https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack# https://ctf.rip/sharif-ctf-2016-lsb-oracle-crypto-challenge/# https://introspelliam.github.io/2018/03/27/crypto/RSA-Least-Significant-Bit-Oracle-Attack/import libnum, gmpy2, socket, time, decimaldef oracle(c1): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) hostname = '47.96.239.28' port = 23333 s.connect((hostname, port)) s.recv(1024) s.send(hex(c1)[2:].strip("lL") + '\n') res = s.recv(1024).strip() s.close() if res == 'even': return 0 if res == 'odd': return 1 else: assert (0)def partial(c, n): global c_of_2 k = n.bit_length() decimal.getcontext().prec = k # allows for 'precise enough' floats lower = decimal.Decimal(0) upper = decimal.Decimal(n) for i in range(k): possible_plaintext = (lower + upper) / 2 # lower==0 when i&lt;1809 flag = oracle(c) if not flag: upper = possible_plaintext # plaintext is in the lower half else: lower = possible_plaintext # plaintext is in the upper half c = (c * c_of_2) % n # multiply y by the encryption of 2 again print i, flag, int(upper - lower) # time.sleep(0.2) # By now, our plaintext is revealed! return int(upper)def main(): print "[*] Conducting Oracle attack..." return partial((c * c_of_2) % n, n)if __name__ == '__main__': e = 0x10001 n = 0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716db c = 0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0 c_of_2 = pow(2, e, n) m = main() # m = 560856645743734814774953158390773525781916094468093308691660509501812349 print libnum.n2s(m) # QCTF&#123;RSA_parity_oracle_is_fun&#125; 选择密文攻击适用情况：可以构造任意密文并获得对应明文。 这个好理解，在一个RSA加密过程中，明文为m，密文为c，模数为n，加密指数为e，选取x以满足gcd(x,n)==1 从而使x模n的逆存在，构造密文 c&#39;=c*(x^e) 使解密后明文为 m&#39;=(m*x)%n ，则m=m&#39;*x^-1(mod n) 。可参看模意义下的运算法则部分 。 广播攻击适用情况：模数n、密文c不同，明文m、加密指数e相同。一般会是e=k，然后给k组数据 使用不同的模数n，相同的公钥指数e加密相同的信息。就会得到多个(m^e) ==ci (mod ni)，将(m^e)视为一个整体M，这就是典型的中国剩余定理适用情况。按照本文的中国剩余定理小节容易求得m^e的值，当e较小时直接开e方即可，可使用gmpy2.iroot(M,e) 方法。 Python实现：参见本文 中国剩余定理小节。 例子：2018强网杯nextrsa-Level9123456789m = random.randint(0x100000000000, 0xffffffffffff)e = 3n1 = 0x43d819a4caf16806e1c540fd7c0e51a96a6dfdbe68735a5fd99a468825e5ee55c4087106f7d1f91e10d50df1f2082f0f32bb82f398134b0b8758353bdabc5ba2817f4e6e0786e176686b2e75a7c47d073f346d6adb2684a9d28b658dddc75b3c5d10a22a3e85c6c12549d0ce7577e79a068405d3904f3f6b9cc408c4cd8595bf67fe672474e0b94dc99072caaa4f866fc6c3feddc74f10d6a0fb31864f52adef71649684f1a72c910ec5ca7909cc10aef85d43a57ec91f096a2d4794299e967fcd5add6e9cfb5baf7751387e24b93dbc1f37315ce573dc063ecddd4ae6fb9127307cfc80a037e7ff5c40a5f7590c8b2f5bd06dd392fbc51e5d059cffbcb85555Ln2 = 0x60d175fdb0a96eca160fb0cbf8bad1a14dd680d353a7b3bc77e620437da70fd9153f7609efde652b825c4ae7f25decf14a3c8240ea8c5892003f1430cc88b0ded9dae12ebffc6b23632ac530ac4ae23fbffb7cfe431ff3d802f5a54ab76257a86aeec1cf47d482fec970fc27c5b376fbf2cf993270bba9b78174395de3346d4e221d1eafdb8eecc8edb953d1ccaa5fc250aed83b3a458f9e9d947c4b01a6e72ce4fee37e77faaf5597d780ad5f0a7623edb08ce76264f72c3ff17afc932f5812b10692bcc941a18b6f3904ca31d038baf3fc1968d1cc0588a656d0c53cd5c89cedba8a5230956af2170554d27f524c2027adce84fd4d0e018dc88ca4d5d26867Ln3 = 0x280f992dd63fcabdcb739f52c5ed1887e720cbfe73153adf5405819396b28cb54423d196600cce76c8554cd963281fc4b153e3b257e96d091e5d99567dd1fa9ace52511ace4da407f5269e71b1b13822316d751e788dc935d63916075530d7fb89cbec9b02c01aef19c39b4ecaa1f7fe2faf990aa938eb89730eda30558e669da5459ed96f1463a983443187359c07fba8e97024452087b410c9ac1e39ed1c74f380fd29ebdd28618d60c36e6973fc87c066cae05e9e270b5ac25ea5ca0bac5948de0263d8cc89d91c4b574202e71811d0ddf1ed23c1bc35f3a042aac6a0bdf32d37dede3536f70c257aafb4cfbe3370cd7b4187c023c35671de3888a1ed1303Lc1 = pow(m, e, n1)c2 = pow(m, e, n2)c3 = pow(m, e, n3)print m == gmpy2.iroot(CRT([n1, n2, n3], [c1, c2, c3]), e)[0] 其他例题【Jarvis OJ Medium RSA】解析公钥文件使用命令从PEM文件（Privacy-Enhanced Mail 是用于存储和发送密钥、证书等数据的文件格式）中解析公钥对(n,e)，n可在线查询 (http://factordb.com/) 到质因子，分解n得到p和q，便能够计算欧拉函数值及解密指数，从而解密。 123456789101112131415C:\Users\neo\Downloads\mediumRSA.rarλ openssl rsa -pubin -text -modulus -in pubkey.pemWARNING: can't open config file: /usr/local/ssl/openssl.cnfPublic-Key: (256 bit)Modulus: 00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:ddExponent: 65537 (0x10001)Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDwriting RSA key-----BEGIN PUBLIC KEY-----MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDryigb/+l/vjDdAgMBAAE=-----END PUBLIC KEY----- carck.py 1234567891011import gmpy2,binasciin=87924348264132406875276140514499937145050893665602592992418171647042491658461e=0x10001# via http://factordb.com/p=275127860351348928173285174381581152299q=319576316814478949870590164193048041239d=gmpy2.invert(e,(p-1)*(q-1))c=int(open('flag.enc','rb').read().encode('hex'),16)m=hex(pow(c,d,n))[2:]print binascii.unhexlify(m.zfill(len(m)+8-len(m)%8)) 后话RSA可谓现代密码学的中流砥柱，关于它的可行攻击方法研究还有很多，诸如Timing Attack ，Padding oracle attack，Side-channel analysis attacks等类型的攻击，本文仅介绍了一些通俗易懂的方法，读者还可以阅读 CTF wiki中的非对称加密部分 ，以及以 RSA (cryptosystem) 为目录结合谷歌进行进一步学习。 本文的例题附件、代码段、工具和后续更新都会放在 RSA-ATTACK ，欢迎 star &amp; watch 。 参考链接Practical Padding Oracle Attacks on RSA CTF wiki中的非对称加密部分]]></content>
      <tags>
        <tag>技术</tag>
        <tag>安全</tag>
        <tag>密码学</tag>
        <tag>学习笔记</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[培根密码栅栏密码]]></title>
    <url>%2F2018%2F02%2F15%2Fbacon-fence%2F</url>
    <content type="text"><![CDATA[接上一篇的AES，在写Crypto类库时也写了培根密码和栅栏密码，这里也写一下这两中加密算法。 培根密码培根密码，又名倍康尼密码（英语：Bacon’s cipher）是由法兰西斯·培根发明的一种隐写术。[维基百科] 原理加密时，明文中的每个字母都会转换成一组五个英文字母。其转换依靠下表：123456a AAAAA g AABBA n ABBAA t BAABAb AAAAB h AABBB o ABBAB u-v BAABBc AAABA i-j ABAAA p ABBBA w BABAAd AAABB k ABAAB q ABBBB x BABABe AABAA l ABABA r BAAAA y BABBAf AABAB m ABABB s BAAAB z BABBB 这只是一款最常用的加密表，有另外一款将每种字母配以不同的字母组予以转换，即I与J、U与V皆有不同编号。 加密者需使用两种不同字体，分别代表A和B。准备好一篇包含相同AB字数的假信息后，按照密文格式化假信息，即依密文中每个字母是A还是B分别套用两种字体。 解密时，将上述方法倒转。所有字体一转回A，字体二转回B，以后再按上表拼回字母。 法兰西斯·培根另外准备了一种方法，其将大小写分别看作A与B，可用于无法使用不同字体的场合（例如只能处理纯文本时）。但这样比起字体不同更容易被看出来，而且和语言对大小写的要求也不太兼容。 培根密码本质上是将二进制信息通过样式的区别，加在了正常书写之上。培根密码所包含的信息可以和用于承载其的文章完全无关。 代码实现代码这里只写加密算法了，解密也类似于摩斯密码，具体可以去Github看我的Crypto类库，使用时直接引用就行了。12345678910111213141516171819202122232425static private string[] baconArray = &#123; "AAAAA", "AAAAB", "AAABA", "AAABB", "AABAA", "AABAB", "AABBA","AABBB","ABAAA","ABAAA","ABAAB","ABABA","ABABB","ABBAA","ABBAB","ABBBA","ABBBB", "BAAAA","BAAAB","BAABA","BAABB","BAABB","BABAA","BABAB","BABBA","BABBB"&#125;;/// &lt;summary&gt;/// 培根加密/// &lt;/summary&gt;/// &lt;param name="str"&gt;明文&lt;/param&gt;/// &lt;returns&gt;密文&lt;/returns&gt;static public string baconEncrypt(string str)&#123; str = str.ToUpper(); string result = ""; for (int i = 0; i &lt; str.Length; i++) &#123; char ch = str[i]; if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') &#123; result += baconArray[ch - 'A']; &#125; else throw new Exception("输入有误"); &#125; return result;&#125; 结果1234请输入要加解密的字符串：willv培根加密结果为：BABAAABAAAABABAABABABAABB请输入要加解密的字符串：BABAAABAAAABABAABABABAABB培根加密结果为：WI(J)LLU(V) 栅栏密码栅栏密码，就是把要加密的明文分成N个一组，然后把每组的第1个字连起来，形成一段无规律的话。 不过栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多。（一般不超过30个，也就是一、两句话） 加解密实例[百度百科]一般比较常见的是2栏的栅栏密码。比如明文：THERE IS A CIPHER去掉空格后变为：THEREISACIPHER两个一组，得到：TH ER EI SA CI PH ER先取出第一个字母：TEESCPE再取出第二个字母：HRIAIHR连在一起就是：TEESCPEHRIAIHR还原为所需密码。而解密的时候，我们先把密文从中间分开，变为两行：T E E S C P EH R I A I H R再按上下上下的顺序组合起来：THEREISACIPHER分出空格，就可以得到原文了：THERE IS A CIPHER不是所有密码都分为两栏，比如：明文：THERE IS A CIPHER七个一组：THEREIS ACIPHER抽取字母：TA HC EI RP EH IE SR组合得到密码：TAHCEIRPEHIESR那么这时候就无法再按照2栏的方法来解了…1分析解码这样，我们可以通过分析密码的字母数来解出密码…比如：TAHCEIRPEHIESR一共有14个字母，可能是2栏或者7栏…尝试2栏…失败尝试7栏…成功 代码实现栅栏密码的代码实现也比较简单。我还另外写了一个获取栅栏数的函数。1234567891011121314str = str.Replace(" ", "");int length = str.Length;int[] result;Stack&lt;int&gt; s = new Stack&lt;int&gt; &#123; &#125;;//分解因数for (int i = 2; i &lt; System.Math.Sqrt(length); i++) //博扬大佬说到开根号就行了&#123; if (length%i==0) &#123; s.Push(i); &#125;&#125;result = s.Reverse().ToArray();return result; 以栅栏密码加密为例（我在类库Crypto中加入了移除空格，如果需要空格的话需要重编译一下删除替换代码）123456789101112131415161718192021222324252627282930313233343536373839/// &lt;summary&gt;/// 栅栏密码加密/// &lt;/summary&gt;/// &lt;param name="str"&gt;明文&lt;/param&gt;/// &lt;param name="num"&gt;栅栏数&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;static public string fenceEncrypt(string str,int num)&#123; /* * 明文：THERE IS A CIPHER * 七个一组：THEREIS ACIPHER * 抽取字母：TA HC EI RP EH IE SR * 组合得到密码：TAHCEIRPEHIESR */ str = str.Replace(" ", ""); if (str.Length%num!=0) &#123; throw new Exception("栅栏数错误"); &#125; int cp = str.Length / num; //可分的组数 string[] temp = new string[cp]; //保存分组 for (int i = 0; i &lt; cp; i++) //为分组复制 &#123; for (int j = 0; j &lt; num; j++) &#123; temp[i] += str[i * num + j]; &#125; &#125; string result = ""; //抽取字母 for (int i = 0; i &lt; num; i++) &#123; for (int j = 0; j &lt; cp; j++) &#123; result += temp[j][i]; &#125; &#125; return result;&#125; 栅栏密码的解密很简单，比如长度35的明文栅栏数5加密后，对密文进行以栅栏数为7再加密一次就可以解密了，数学证明很简单在这里就不写了。 结果以实例中的字符串THERE IS A CIPHER为例1234请输入要加解密的字符串：THERE IS A CIPHER栅栏加密结果为：TEESCPEHRIAIHR请输入要加解密的字符串：TEESCPEHRIAIHR栅栏解密结果为：THEREISACIPHER]]></content>
      <tags>
        <tag>技术</tag>
        <tag>安全</tag>
        <tag>密码学</tag>
        <tag>学习笔记</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AES学习]]></title>
    <url>%2F2018%2F02%2F13%2Faes-study%2F</url>
    <content type="text"><![CDATA[最近在写一个常见加密编码的类库Crypto，其中涉及到很多加密及编码方式。写到了AES这里，遇到点麻烦，也是学习了一下AES加密。 高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。该算法为比利时密码学家Joan Daemen和Vincent Rijmen所设计，结合两位作者的名字，以Rijndael为名投稿高级加密标准的甄选流程。（Rijndael的发音近于”Rhine doll”）（来自维基百科） AES高级加密标准 - 维基百科严格地说，AES和Rijndael加密法并不完全一样（虽然在实际应用中两者可以互换），因为Rijndael加密法可以支持更大范围的区块和密钥长度：AES的区块长度固定为128比特，密钥长度则可以是128，192或256比特；而Rijndael使用的密钥和区块长度均可以是128，192或256比特。加密过程中使用的密钥是由Rijndael密钥生成方案产生。 大多数AES计算是在一个特别的有限域完成的。 AES加密过程是在一个4×4的字节矩阵上运作，这个矩阵又称为“体（state）”，其初值就是一个明文区块（矩阵中一个元素大小就是明文区块中的一个Byte）。（Rijndael加密法因支持更大的区块，其矩阵行数可视情况增加）加密时，各轮AES加密循环（除最后一轮外）均包含4个步骤： AddRoundKey—矩阵中的每一个字节都与该次回合密钥（round key）做XOR运算；每个子密钥由密钥生成方案产生。 SubBytes—通过一个非线性的替换函数，用查找表的方式把每个字节替换成对应的字节。 ShiftRows—将矩阵中的每个横列进行循环式移位。 MixColumns—为了充分混合矩阵中各个直行的操作。这个步骤使用线性转换来混合每内联的四个字节。最后一个加密循环中省略MixColumns步骤，而以另一个AddRoundKey取代。 分组密码工作模式分组密码工作模式 - 维基百科密码学中，分组（block）密码的工作模式（mode of operation）允许使用同一个分组密码密钥对多于一块的数据进行加密，并保证其安全性。分组密码自身只能加密长度等于密码分组长度的单块数据，若要加密变长数据，则数据必须先被划分为一些单独的密码块。通常而言，最后一块数据也需要使用合适填充方式将数据扩展到匹配密码块大小的长度。一种工作模式描述了加密每一数据块的过程，并常常使用基于一个通常称为初始化向量的附加输入值以进行随机化，以保证安全。 工作模式主要用来进行加密和认证。对加密模式的研究曾经包含数据的完整性保护，即在某些数据被修改后的情况下密码的误差传播特性。后来的研究则将完整性保护作为另一个完全不同的，与加密无关的密码学目标。部分现代的工作模式用有效的方法将加密和认证结合起来，称为认证加密模式。 虽然工作模式通常应用于对称加密，它亦可以应用于公钥加密，例如在原理上对RSA进行处理，但在实用中，公钥密码学通常不用于加密较长的信息，而是使用结合对称加密和公钥加密的混合加密方案。 初始化向量（IV）初始化向量 - 维基百科初始化向量（IV，Initialization Vector）是许多任务作模式中用于将加密随机化的一个位块，由此即使同样的明文被多次加密也会产生不同的密文，避免了较慢的重新产生密钥的过程。 初始化向量与密钥相比有不同的安全性需求，因此IV通常无须保密，然而在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个IV。对于CBC和CFB，重用IV会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。对于OFB和CTR而言，重用IV会导致完全失去安全性。另外，在CBC模式中，IV在加密时必须是无法预测的；特别的，在许多实现中使用的产生IV的方法，例如SSL2.0使用的，即采用上一个消息的最后一块密文作为下一个消息的IV，是不安全的。 填充填充 (密码学) - 维基百科块密码只能对确定长度的数据块进行处理，而消息的长度通常是可变的。因此部分模式（即ECB和CBC）需要最后一块在加密前进行填充。有数种填充方法，其中最简单的一种是在明文的最后填充空字符以使其长度为块长度的整数倍，但必须保证可以恢复明文的原始长度；例如，若明文是C语言风格的字符串，则只有串尾会有空字符。稍微复杂一点的方法则是原始的DES使用的方法，即在数据后添加一个1位，再添加足够的0位直到满足块长度的要求；若消息长度刚好匹配块长度，则添加一个填充块。最复杂的则是针对CBC的方法，例如密文窃取，残块终结等，不会产生额外的密文，但会增加一些复杂度。布鲁斯·施奈尔和尼尔斯·弗格森提出了两种简单的可能性：添加一个值为128的字节（十六进制的80），再以0字节填满最后一个块；或向最后一个块填充n个值均为n的字节。 CFB，OFB和CTR模式不需要对长度不为密码块大小整数倍的消息进行特别的处理。因为这些模式是通过对块密码的输出与明文进行异或工作的。最后一个明文块（可能是不完整的）与密钥流块的前几个字节异或后，产生了与该明文块大小相同的密文块。流密码的这个特性使得它们可以应用在需要密文和明文数据长度严格相等的场合，也可以应用在以流形式传输数据而不便于进行填充的场合。 常用模式电子密码本（ECB）最简单的加密模式即为电子密码本（Electronic codebook，ECB）模式。需要加密的消息按照块密码的块大小被分为数个块，并对每个块进行独立加密。 本方法的缺点在于同样的明文块会被加密成相同的密文块；因此，它不能很好的隐藏数据模式。在某些场合，这种方法不能提供严格的数据保密性，因此并不推荐用于密码协议中。ECB模式也会导致使用它的协议不能提供数据完整性保护，易受到重放攻击的影响，因此每个块是以完全相同的方式解密的。例如，“梦幻之星在线：蓝色脉冲”在线电子游戏使用ECB模式的Blowfish密码。在密钥交换系统被破解而产生更简单的破解方式前，作弊者重复通过发送加密的“杀死怪物”消息包以非法的快速增加经验值。 密码块链接（CBC）1976年，IBM发明了密码分组链接（CBC，Cipher-block chaining）模式。在CBC模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。 若第一个块的下标为1，则CBC模式的加密过程为而其解密过程则为CBC是最为常用的工作模式。它的主要缺点在于加密过程是串行的，无法被并行化，而且消息必须被填充到块大小的整数倍。解决后一个问题的一种方法是利用密文窃取。 注意在加密时，明文中的微小改变会导致其后的全部密文块发生改变，而在解密时，从两个邻接的密文块中即可得到一个明文块。因此，解密过程可以被并行化，而解密时，密文中一位的改变只会导致其对应的明文块完全改变和下一个明文块中对应位发生改变，不会影响到其它明文的内容。 填充密码块链接（PCBC）填充密码块链接（PCBC，Propagating cipher-block chaining）或称为明文密码块链接（Plaintext cipher-block chaining），是一种可以使密文中的微小更改在解密时导致明文大部分错误的模式，并在加密的时候也具有同样的特性。加密和解密算法如下：PCBC主要用于Kerberos v4和WASTE中，而在其它场合的应用较少。对于使用PCBC加密的消息，互换两个邻接的密文块不会对后续块的解密造成影响。正因为这个特性，Kerberos v5没有使用PCBC。 密文反馈（CFB）密文反馈（CFB，Cipher feedback）模式类似于CBC，可以将块密码变为自同步的流密码；工作过程亦非常相似，CFB的解密过程几乎就是颠倒的CBC的加密过程： 上述公式是描述的是最简单的CFB，在这种模式下，它的自同步特性仅仅与CBC相同，即若密文的一整块发生错误，CBC和CFB都仍能解密大部分数据，而仅有一位数据错误。若需要在仅有了一位或一字节错误的情况下也让模式具有自同步性，必须每次只加密一位或一字节。可以将移位寄存器作为块密码的输入，以利用CFB的自同步性。 与CBC相似，明文的改变会影响接下来所有的密文，因此加密过程不能并行化；而同样的，与CBC类似，解密过程是可以并行化的。在解密时，密文中一位数据的改变仅会影响两个明文块：对应明文块中的一位数据与下一块中全部的数据，而之后的数据将恢复正常。 CFB拥有一些CBC所不具备的特性，这些特性与OFB和CTR的流模式相似：只需要使用块密码进行加密操作，且消息无需进行填充（虽然密文窃取也允许数据不进行填充）。 输出反馈（OFB）输出反馈模式（Output feedback, OFB）可以将块密码变成同步的流密码。它产生密钥流的块，然后将其与明文块进行异或，得到密文。与其它流密码一样，密文中一个位的翻转会使明文中同样位置的位也产生翻转。这种特性使得许多错误校正码，例如奇偶校验位，即使在加密前计算，而在加密后进行校验也可以得出正确结果。 由于XOR操作的对称性，加密和解密操作是完全相同的： 每个使用OFB的输出块与其前面所有的输出块相关，因此不能并行化处理。然而，由于明文和密文只在最终的异或过程中使用，因此可以事先对IV进行加密，最后并行的将明文或密文进行并行的异或处理。 可以利用输入全0的CBC模式产生OFB模式的密钥流。这种方法十分实用，因为可以利用快速的CBC硬件实现来加速OFB模式的加密过程。 计数器模式（CTR）注意：CTR模式（Counter mode，CM）也被称为ICM模式（Integer Counter Mode，整数计数模式）和SIC模式（Segmented Integer Counter）。与OFB相似，CTR将块密码变为流密码。它通过递增一个加密计数器以产生连续的密钥流，其中，计数器可以是任意保证长时间不产生重复输出的函数，但使用一个普通的计数器是最简单和最常见的做法。使用简单的、定义好的输入函数是有争议的：批评者认为它“有意的将密码系统暴露在已知的、系统的输入会造成不必要的风险”。目前，CTR已经被广泛的使用了，由输入函数造成的问题被认为是使用的块密码的缺陷，而非CTR模式本身的弱点。无论如何，有一些特别的攻击方法，例如基于使用简单计数器作为输入的硬件差错攻击。 CTR模式的特征类似于OFB，但它允许在解密时进行随机存取。由于加密和解密过程均可以进行并行处理，CTR适合运用于多处理器的硬件上。 注意图中的“nonce”与其它图中的IV（初始化向量）相同。IV、随机数和计数器均可以通过连接，相加或异或使得相同明文产生不同的密文。 代码实现代码为C#，为128位AES加解密（CBC模式PKCS7填充），需要引入命名空间System.Security.Cryptography1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/// &lt;summary&gt;/// AES加密（CBC模式PKCS7填充）/// &lt;/summary&gt;/// &lt;param name="text"&gt;加密字符&lt;/param&gt;/// &lt;param name="password"&gt;加密的密码&lt;/param&gt;/// &lt;param name="iv"&gt;密钥向量&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string AESEncrypt(string text, string password, string iv)&#123; int size = 128; int bytesNum = size / 8; RijndaelManaged rijndaelCipher = new RijndaelManaged(); rijndaelCipher.Mode = CipherMode.CBC; rijndaelCipher.Padding = PaddingMode.PKCS7; rijndaelCipher.KeySize = size; rijndaelCipher.BlockSize = 128; byte[] pwdBytes = System.Text.Encoding.UTF8.GetBytes(password); byte[] keyBytes = new byte[bytesNum]; int len = pwdBytes.Length; if (len &gt; keyBytes.Length) len = keyBytes.Length; System.Array.Copy(pwdBytes, keyBytes, len); rijndaelCipher.Key = keyBytes; byte[] ivBytes = System.Text.Encoding.UTF8.GetBytes(iv); rijndaelCipher.IV = ivBytes; ICryptoTransform transform = rijndaelCipher.CreateEncryptor(); byte[] plainText = Encoding.UTF8.GetBytes(text); byte[] cipherBytes = transform.TransformFinalBlock(plainText, 0, plainText.Length); return Convert.ToBase64String(cipherBytes);&#125;/// &lt;summary&gt;/// 随机生成密钥向量/// &lt;/summary&gt;/// &lt;param name="n"&gt;位数&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string GetIv(int n)&#123; char[] arrChar = new char[]&#123; 'a','b','d','c','e','f','g','h','i','j','k','l','m','n','p','r','q','s','t','u','v','w','z','y','x', '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','Q','P','R','T','S','V','U','W','X','Y','Z' &#125;; StringBuilder num = new StringBuilder(); Random rnd = new Random(DateTime.Now.Millisecond); for (int i = 0; i &lt; n; i++) &#123; num.Append(arrChar[rnd.Next(0, arrChar.Length)].ToString()); &#125; return num.ToString();&#125;/// &lt;summary&gt;/// AES解密（CBC模式PKCS7填充）/// &lt;/summary&gt;/// &lt;param name="text"&gt;密文&lt;/param&gt;/// &lt;param name="password"&gt;密码&lt;/param&gt;/// &lt;param name="iv"&gt;密钥向量&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string AESDecrypt(string text, string password, string iv)&#123; int size = 128; int bytesNum = size / 8; RijndaelManaged rijndaelCipher = new RijndaelManaged(); rijndaelCipher.Mode = CipherMode.CBC; //CBC加密模式 rijndaelCipher.Padding = PaddingMode.PKCS7; //PKCS7填充 rijndaelCipher.KeySize = size; rijndaelCipher.BlockSize = 128; byte[] encryptedData = Convert.FromBase64String(text); byte[] pwdBytes = System.Text.Encoding.UTF8.GetBytes(password); byte[] keyBytes = new byte[bytesNum]; int len = pwdBytes.Length; if (len &gt; keyBytes.Length) len = keyBytes.Length; System.Array.Copy(pwdBytes, keyBytes, len); rijndaelCipher.Key = keyBytes; byte[] ivBytes = System.Text.Encoding.UTF8.GetBytes(iv); rijndaelCipher.IV = ivBytes; ICryptoTransform transform = rijndaelCipher.CreateDecryptor(); byte[] plainText = transform.TransformFinalBlock(encryptedData, 0, encryptedData.Length); return Encoding.UTF8.GetString(plainText);&#125; 测试运行：123456789请输入要加解密的字符串：时光随机生成的iv为:8EAD20lxJlHdRcwr请输入密码:willv128位AES(CBC)加密:elbuc+G8ycb6ydwVrRLyhQ==请输入要加解密的字符串：elbuc+G8ycb6ydwVrRLyhQ==请输入iv:8EAD20lxJlHdRcwr请输入密码:willv128位AES(CBC)解密:时光]]></content>
      <tags>
        <tag>技术</tag>
        <tag>安全</tag>
        <tag>密码学</tag>
        <tag>学习笔记</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一言API调用]]></title>
    <url>%2F2018%2F01%2F14%2Fhitokoto%2F</url>
    <content type="text"><![CDATA[一言是一个非常棒的一句话服务关于如何调用一言API到自己的博客中呢?首先可以看一下一言的API的内容：http://hitokoto.cn/api这里提供一个简单的调用js123456789101112131415161718window.onload=function () &#123; var hitokoto = document.querySelector('.hitokoto'); var from = document.querySelector('.from'); update(); function update() &#123; gethi = new XMLHttpRequest(); gethi.open("GET","https://sslapi.hitokoto.cn/?c=a"); //这里选择类别，详见官方文档 gethi.send(); gethi.onreadystatechange = function () &#123; if (gethi.readyState===4 &amp;&amp; gethi.status===200) &#123; var Hi = JSON.parse(gethi.responseText); hitokoto.innerHTML = Hi.hitokoto; from.innerHTML = "from: &lt;b&gt;" + Hi.from + "&lt;/b&gt;"; //可自定义输出格式 &#125; &#125; &#125;&#125; 接下来可以直接在网页上通过hitokoto和from两个class调用了，例如：1234&lt;div&gt; &lt;p class="hitokoto"&gt;&lt;/p&gt; &lt;p class="from"&gt;&lt;/p&gt;&lt;/div&gt; 如何在Hexo中调用一言呢？很简单。以我的主题next为例。在目录\themes\next\source\js\src（新版next没有src文件夹）下新建hitokoto.js把调用js写进去。如果要经常性的调用，要写在网页中，那么就在\themes\next\layout\_layout.swig的最下面的&lt;/body&gt;前新增一行。 1&lt;script type="text/javascript" src="/js/src/hitokoto.js"&gt;&lt;/script&gt; 如果只在某个网页中使用不必这样，在md中引用javascript即可，引用格式同上面的_layout.swig增加的那行相同。在写文章时在md文件里直接写1234&lt;div&gt; &lt;p class="hitokoto"&gt;&lt;/p&gt; &lt;p class="from"&gt;&lt;/p&gt;&lt;/div&gt; 就可以了。效果如下： 当然，你可以改成任何你喜欢的样子。js代码可以改，html也可以。我感觉这样斜体也不错（参见关于）：123&lt;div&gt; &lt;i class="hitokoto"&gt;&lt;/i&gt;&lt;i class="from"&gt;&lt;/i&gt;&lt;/div&gt; 还有一个带二维码的hitokoto.html值得注意的是，这种调用方法只能同时调用一次。如有需要可以自己改一下代码。参考文章：一言Hitokoto API 调用指南]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提问的艺术]]></title>
    <url>%2F2018%2F01%2F10%2Fhow-to-ask%2F</url>
    <content type="text"><![CDATA[提问之前在通过电邮、新闻组或者聊天室提出技术问题前，检查你有没有做到： 1.通读手册，试着自己找答案。2.在FAQ里找答案（一份维护得好的FAQ可以包罗万象:）。3.在网上搜索（个人推荐google~~~）。4.向你身边精于此道的朋友打听。 当你提出问题的时候，首先要说明在此之前你干了些什么；这将有助于树立你的形象：你不是一个妄图不劳而获的乞讨者，不愿浪费别人的时间。如果提问者能从答案中学到东西，我们更乐于回答他的问题。 周全的思考，准备好你的问题，草率的发问只能得到草率的回答，或者根本得不到任何答案。越表现出在寻求帮助前为解决问题付出的努力，你越能得到实质性的帮助。 小心别问错了问题。如果你的问题基于错误的假设，普通黑客（J. Random Hacker）通常会用无意义的字面解释来答复你，心里想着“蠢问题…”，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。 决不要自以为够资格得到答案，你没这种资格。毕竟你没有为这种服务支付任何报酬。你要自己去“挣”回一个答案，靠提出一个有内涵的，有趣的，有思维激励作用的问题–一个对社区的经验有潜在贡献的问题，而不仅仅是被动的从他人处索要知识–去挣到这个答案。 另一方面，表明你愿意在找答案的过程中做点什么，是一个非常好的开端。“谁能给点提示？”、“我这个例子里缺了什么？”以及“我应该检查什么地方？”比“请把确切的过程贴出来”更容易得到答复。因为你显得只要有人指点正确的方向，你就有完成它的能力和决心。 怎样提问-谨慎选择论坛 小心选择提问的场合。如果象下面描述的那样，你很可能被忽略掉或者被看作失败者： 1.在风马牛不相及的论坛贴出你的问题2.在探讨高级技巧的论坛张贴非常初级的问题；反之亦然3.在太多的不同新闻组交叉张贴 -用辞贴切，语法正确，拼写无误 我们从经验中发现，粗心的写作者通常也是马虎的思考者（我敢打包票）。 回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。 正确的拼写，标点符号和大小写很重要。 更一般的说，如果你的提问写得象个半文盲，你很有可能被忽视。 如果你在使用非母语的论坛提问，你可以犯点拼写和语法上的小错–但决不能在思考上马虎（没错，我们能弄清两者的分别）。 -使用含义丰富，描述准确的标题 在邮件列表或者新闻组中，大约50字以内的主题标题是抓住资深专家注意力的黄金时机。别用喋喋不休的“帮帮忙”（更别说“救命啊！！！！！”这样让人反感的话）来浪费这个机会。不要妄想用你的痛苦程度来打动我们， 别用空格代替问题的描述，哪怕是极其简短的描述。 蠢问题： 救命啊！我的膝上机不能正常显示了！ 聪明问题：XFree86 4.1下鼠标光标变形，Fooware MV1005的显示芯片。 如果你在回复中提出问题，记得要修改内容标题，表明里面有一个问题。一个看起来象“Re：测试”或者“Re：新bug”的问题很难引起足够重视。另外，引用并删减前文的内容，给新来的读者留下线索。 -精确描述，信息量大 1.谨慎明确的描述症状。2.提供问题发生的环境（机器配置、操作系统、应用程序以及别的什么）。3.说明你在提问前是怎样去研究和理解这个问题的。4.说明你在提问前采取了什么步骤去解决它。5.罗列最近做过什么可能有影响的硬件、软件变更。 尽量想象一个黑客会怎样反问你，在提问的时候预先给他答案。 Simon Tatham写过一篇名为《如何有效的报告Bug》的出色短文。强力推荐你也读一读。 -话不在多 你需要提供精确有效的信息。这并不是要求你简单的把成吨的出错代码或者数据完全转储摘录到你的提问中。如果你有庞大而复杂的测试条件，尽量把它剪裁得越小越好。 这样做的用处至少有三点。第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；第二，简化问题使你得到有用答案的机会增加；第三，在提炼你的bug报告的过程中，也许你自己就能找出问题所在或作出更正。 -只说症状，不说猜想 告诉黑客们你认为问题是怎样引起的没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，不要加进你自己的理解和推论。让黑客们来诊断吧。 蠢问题： 我在内核编译中一次又一次遇到SIG11错误，我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？ 聪明问题： 我自制的一套K6/233系统，主板是FIC-PA2007（VIA Apollo VP2芯片组），256MB Corsair PC133 SDRAM，在内核编译中频频产生SIG11错误，从开机20分钟以后就有这种情况，开机前20分钟内从没发生过。重启也没有用，但是关机一晚上就又能工作20分钟。所有内存都换过了，没有效果。相关部分的典型编译记录如下…。 -按时间顺序列出症状 对找出问题最有帮助的线索，往往就是问题发生前的一系列操作，因此，你的说明应该包含操作步骤，以及电脑的反应，直到问题产生。 如果你的说明很长（超过四个段落），在开头简述问题会有所帮助，接下来按时间顺序详述。这样黑客们就知道该在你的说明中找什么。 -明白你想问什么 漫无边际的提问近乎无休无止的时间黑洞。最能给你有用答案的人也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞不太感冒，因此也可以说他们对漫无边际的提问不大感冒。 如果你明确表述需要回答者做什么（提供建议，发送一段代码，检查你的补丁或是别的），就最有可能得到有用的答案。这会定出一个时间和精力的上限，便于回答者集中精力来帮你，这很奏效。要理解专家们生活的世界，要把专业技能想象为充裕的资源，而回复的时间则是贫乏的资源。解决你的问题需要的时间越少，越能从忙碌的专家口中掏出答案。 因此，优化问题的结构，尽量减少专家们解决它所需要的时间，会有很大的帮助–这通常和简化问题有所区别。因此，问“我想更好的理解X，能给点提示吗？”通常比问“你能解释一下X吗？”更好。如果你的代码不能工作，问问它有什么地方不对，比要求别人替你修改要明智得多。 -别问应该自己解决的问题 黑客们总是善于分辨哪些问题应该由你自己解决；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由你来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。 -去除无意义的疑问 别用无意义的话结束提问，例如“有人能帮我吗？”或者“有答案吗？”。首先：如果你对问题的描述不很合适，这样问更是画蛇添足。其次：由于这样问是画蛇添足，黑客们会很厌烦你–而且通常会用逻辑上正确的回答来表示他们的蔑视，例如：“没错，有人能帮你”或者“不，没答案”。 -谦逊绝没有害处，而且常帮大忙 彬彬有礼，多用“请”和“先道个谢了”。让大家都知道你对他们花费时间义务提供帮助心存感激。然而，如果你有很多问题无法解决，礼貌将会增加你得到有用答案的机会。 （我们注意到，自从本指南发布后，从资深黑客处得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得“先谢了”的言外之意是过后就不会再感谢任何人了。我们的建议是：都道谢。） -问题解决后，加个简短说明 问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个补充说明。补充说明不必很长或是很深入；简单的一句“你好，原来是网线出了问题！谢谢大家–Bill”比什么也不说要强。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇学术论文更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。除了表示礼貌和反馈信息以外，这种补充有助于他人在邮件列表/新闻组/论坛中搜索对你有过帮助的完整解决方案，这可能对他们也很有用。最后（至少？），这种补充有助于所有提供过帮助的人从中得到满足感。如果你自己不是老手或者黑客，那就相信我们，这种感觉对于那些你向他们求助的导师或者专家而言，是非常重要的。问题久拖未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次贴出新问题时尝到甜头。 -还是不懂 如果你不是很理解答案，别立刻要求对方解释。象你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），去理解它。如果你真的需要对方解释，记得表现出你已经学到了点什么。比方说，如果我回答你：“看来似乎是zEntry被阻塞了；你应该先清除它。”，然后：一个很糟的后续问题： “zEntry是什么？” 聪明的问法应该是这样：“哦~~~我看过帮助了但是只有-z和-p两个参数中提到了zEntry而且还都没有清楚的解释:&lt;你是指这两个中的哪一个吗？还是我看漏了什么？” 三思而后问以下是几个经典蠢问题，以及黑客在拒绝回答时的心中所想： 问题：我能在哪找到X程序？问题：我的程序/配置/SQL申明没有用问题：我的Windows有问题，你能帮我吗？问题：我在安装Linux（或者X）时有问题，你能帮我吗？问题：我怎么才能破解root帐号/窃取OP特权/读别人的邮件呢？ 提问：我能在哪找到X程序？回答：就在我找到它的地方啊蠢货–搜索引擎的那一头。天呐！还有人不会用Google吗？ 提问：我的程序（配置、SQL申明）没有用回答：这不算是问题吧，我对找出你的真正问题没兴趣–如果要我问你二十个问题才找得出来的话–我有更有意思的事要做呢。 在看到这类问题的时候，我的反应通常不外如下三种： 1.你还有什么要补充的吗？2.真糟糕，希望你能搞定。3.这跟我有什么鸟相关？ 提问：我的Windows有问题，你能帮我吗？回答：能啊，扔掉萎软的垃圾，换Linux吧。 提问：我在安装Linux（或者X）时有问题，你能帮我吗？回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的Linux用户组寻求手把手的指导吧（你能在这儿找到用户组的清单）。 提问：我怎么才能破解root帐号/窃取OP特权/读别人的邮件呢？回答：想要这样做，说明你是个卑鄙小人；想找个黑客帮你，说明你是个ΘΘΘΘ！ 好问题，坏问题最后，我举一些例子来说明，怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。 蠢问题：我可以在哪儿找到关于Foonly Flurbamatic的资料？ //这种问法无非想得到“STFW”这样的回答。 聪明问题：我用Google搜索过“Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？ //这个问题已经STFW过了，看起来他真的遇到了麻烦。 蠢问题：我从FOO项目找来的源码没法编译。它怎么这么烂？ //他觉得都是别人的错，这个傲慢自大的家伙 聪明问题：FOO项目代码在Nulix 6.2版下无法编译通过。我读过了FAQ，但里面没有提到跟Nulix有关的问题。这是我编译过程的记录，我有什么做得不对的地方吗？ //他讲明了环境，也读过了FAQ，还指明了错误，并且他没有把问题的责任推到别人头上，这个家伙值得留意。 蠢问题：我的主板有问题了，谁来帮我？ //普通黑客对这类问题的回答通常是：“好的，还要帮你拍拍背和换尿布吗？” ，然后按下删除键。 聪明问题：我在S2464主板上试过了X、Y和Z，但没什么作用，我又试了A、B和C。请注意当我尝试C时的奇怪现象。显然边带传输中出现了收缩，但结果出人意料。在多处理器主板上引起边带泄漏的通常原因是什么？谁有好主意接下来我该做些什么测试才能找出问题？ //这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。 在最后一个问题中，注意“告诉我答案”和“给我启示，指出我还应该做什么诊断工作”之间微妙而又重要的区别。事实上，后一个问题源自于2001年8月在Linux内核邮件列表上的一个真实的提问。我（Eric）就是那个提出问题的人。我在Tyan S2464主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决那一问题的重要信息。 通过我的提问方法，我给了大家值得玩味的东西；我让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，邀请他们与我共同探讨。我告诉他们我所走过的弯路，以避免他们再浪费时间，这是一种对他人时间价值的尊重。后来，当我向每个人表示感谢，并且赞赏这套程序（指邮件列表中的讨论 –译者注）运作得非常出色的时候，一个Linux内核邮件列（lkml）成员表示，问题得到解决并非由于我是这个列表中的“名人”，而是因为我用了正确的方式来提问。我们黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我象个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，给编写这个指南的人一些指导。 找不到答案怎么办如果仍得不到答案，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。 总的说来，简单的重复张贴问题是个很糟的想法。这将被视为无意义的喧闹。 你可以通过其它渠道获得帮助，这些渠道通常更适合初学者的需要。有许多网上的以及本地的用户组，由狂热的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。 另外，你可以向很多商业公司寻求帮助，不论公司大还是小（Red Hat和LinuxCare就是两个最常见的例子）。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了–完全可能如此– 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。 对大众化的软件，就象Linux之类而言，每个开发者至少会有上万名用户。根本不可能由一个人来处理来自上万名用户的求助电话。要知道，即使你要为帮助付费，同你必须购买同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开放源代码软件要高得多，且内容也不那么丰富）。 如何有效地报告Bug引言 为公众写过软件的人，大概都收到过很拙劣的bug（计算机程序代码中的错误或程序运行时的瑕疵——译者注）报告，例如： 在报告中说“不好用”；所报告内容毫无意义；在报告中用户没有提供足够的信息；在报告中提供了虚假信息；所报告的问题是由于用户的过失而产生的；所报告的问题是由于其他程序的错误而产生的；所报告的问题是由于网络错误而产生的； 这便是为什么“技术支持”被认为是一件可怕的工作，因为有拙劣的bug报告需要处理。然而并不是所有的bug报告都令人生厌：我在业余时间维护自由软件，有时我会收到非常清晰、有帮助并且内容丰富的bug报告。 在这里我会尽力阐明如何写一个好的bug报告。我非常希望每一个人在报告bug之前都读一下这篇短文，当然我也希望用户在给我报告bug之前已经读过这篇文章。 简单地说，报告bug的目的是为了让程序员看到程序的错误。您可以亲自示范，也可以给出能导致程序出错的、详尽的操作步骤。如果程序出错了，程序员会收集额外的信息直到找到错误的原因；如果程序没有出错，那么他们会请您继续关注这个问题，收集相关的信息。 在bug报告里，要设法搞清什么是事实（例如：“我在电脑旁”和“XX出现了”）什么是推测（例如：“我想问题可能是出在……”）。如果愿意的话，您可以省去推测，但是千万别省略事实。 当您报告bug的时候（既然您已经这么做了），一定是希望bug得到及时修正。所以此时针对程序员的任何过激或亵渎的言语（甚至谩骂）都是与事无补的 ——因为这可能是程序员的错误，也有可能是您的错误，也许您有权对他们发火，但是如果您能多提供一些有用的信息（而不是激愤之词）或许bug会被更快的修正。除此以外，请记住：如果是免费软件，作者提供给我们已经是出于好心，所以要是太多的人对他们无礼，他们可能就要“收起”这份好心了。 “程序不好用” 程序员不是弱智：如果程序一点都不好用，他们不可能不知道。他们不知道一定是因为程序在他们看来工作得很正常。所以，或者是您作过一些与他们不同的操作，或者是您的环境与他们不同。他们需要信息，报告bug也是为了提供信息。信息总是越多越好。 许多程序，特别是自由软件，会公布一个“已知bug列表”。如果您找到的bug在列表里已经有了，那就不必再报告了，但是如果您认为自己掌握的信息比列表中的丰富，那无论如何也要与程序员联系。您提供的信息可能会使他们更简单地修复bug。 本文中提到的都是一些指导方针，没有哪一条是必须恪守的准则。不同的程序员会喜欢不同形式的bug报告。如果程序附带了一套报告bug的准则，一定要读。如果它与本文中提到的规则相抵触，那么请以它为准。 如果您不是报告bug，而是寻求帮助，您应该说明您曾经到哪里找过答案，（例如：我看了第四章和第五章的第二节，但我找不到解决的办法。）这会使程序员了解用户喜欢到哪里去找答案，从而使程序员把帮助文档做得更容易使用。 “演示给我看” 报告bug的最好的方法之一是“演示”给程序员看。让程序员站在电脑前，运行他们的程序，指出程序的错误。让他们看着您启动电脑、运行程序、如何进行操作以及程序对您的输入有何反应。 他们对自己写的软件了如指掌，他们知道哪些地方不会出问题，而哪些地方最可能出问题。他们本能地知道应该注意什么。在程序真的出错之前，他们可能已经注意到某些地方不对劲，这些都会给他们一些线索。他们会观察程序测试中的每一个细节，并且选出他们认为有用的信息。 这些可能还不够。也许他们觉得还需要更多的信息，会请您重复刚才的操作。他们可能在这期间需要与您交流一下，以便在他们需要的时候让bug重新出现。他们可能会改变一些操作，看看这个错误的产生是个别问题还是相关的一类问题。如果您不走运，他们可能需要坐下来，拿出一堆开发工具，花上几个小时研究。但是最重要的是在程序出错的时候让程序员在电脑旁。一旦他们看到了问题，他们通常会找到原因并开始试着修改。 “告诉我该怎么做” 如今是网络时代，是信息交流的时代。我可以点一下鼠标把自己的程序送到俄罗斯的某个朋友那里，当然他也可以用同样简单的方法给我一些建议。但是如果我的程序出了什么问题，我不可能在他旁边。“演示”是很好的办法，但是常常做不到。 如果您必须报告bug，而此时程序员又不在您身边，那么您就要想办法让bug重现在他们面前。当他们亲眼看到错误时，就能够进行处理了。 确切地告诉程序员您做了些什么。如果是一个图形界面程序，告诉他们您按了哪个按钮，依照什么顺序按的。如果是一个命令行程序，精确的告诉他们您键入了什么命令。您应该尽可能详细地提供您所键入的命令和程序的反应。 把您能想到的所有的输入方式都告诉程序员，如果程序要读取一个文件，您可能需要发一个文件的拷贝给他们。如果程序需要通过网络与另一台电脑通讯，您或许不能把那台电脑复制过去，但至少可以说一下电脑的类型和安装了哪些软件（如果可以的话）。 “哪儿出错了？在我看来一切正常哦！” 如果您给了程序员一长串输入和指令，他们执行以后没有出现错误，那是因为您没有给他们足够的信息，可能错误不是在每台计算机上都出现，您的系统可能和他们的在某些地方不一样。有时候程序的行为可能和您预想的不一样，这也许是误会，但是您会认为程序出错了，程序员却认为这是对的。 同样也要描述发生了什么。精确的描述您看到了什么。告诉他们为什么您觉得自己所看到的是错误的，最好再告诉他们，您认为自己应该看到什么。如果您只是说：“程序出错了”，那您很可能漏掉了非常重要的信息。 如果您看到了错误消息，一定要仔细、准确的告诉程序员，它们很重要。在这种情况下，程序员只要修正错误，而不用去找错误。他们需要知道是什么出问题了，系统所报的错误消息正好帮助了他们。如果您没有更好的方法记住这些消息，就把它们写下来。只报告“程序出了一个错”是毫无意义的，除非您把错误消息一块报上来。 特殊情况下，如果有错误消息号，一定要把这些号码告诉程序员。不要以为您看不出任何意义，它就没有意义。错误消息号包含了能被程序员读懂的各种信息，并且很有可能包含重要的线索。给错误消息编号是因为用语言描述计算机错误常常令人费解。用这种方式告诉您错误的所在是一个最好的办法。 在这种情形下，程序员的排错工作会十分高效。他们不知道发生了什么，也不可能到现场去观察，所以他们一直在搜寻有价值的线索。错误消息、错误消息号以及一些莫名其妙的延迟，都是很重要的线索，就像办案时的指纹一样重要，保存好。 如果您使用UNIX系统，程序可能会产生一个内核输出（core dump）。内核输出是特别有用的线索来源，别扔了它们。另一方面，大多数程序员不喜欢收到含有大量内核输出文件的EMAIL，所以在发邮件之前最好先问一下。还有一点要注意：内核输出文件记录了完整的程序状态，也就是说任何秘密（可能当时程序正在处理一些私人信息或秘密数据）都可能包含在内核输出文件里。 出了问题之后，我做了……” 当一个错误或bug发生的时候，您可能会做许多事情。但是大多数人会使事情变的更糟。我的一个朋友在学校里误删了她所有的Word文件，在找人帮忙之前她重装了Word，又运行了一遍碎片整理程序，这些操作对于恢复文件是毫无益处的，因为这些操作搞乱了磁盘的文件区块。恐怕在这个世界上没有一种反删除软件能恢复她的文件了。如果她不做任何操作，或许还有一线希望。 这种人仿佛一只被逼到墙角的鼬（黄鼠狼、紫貂一类的动物——译者注）：背靠墙壁，面对死亡的降临奋起反扑，疯狂攻击。他们认为做点什么总比什么都不做强。然而这些在处理计算机软件问题时并不适用。不要做鼬，做一只羚羊。当一只羚羊面对料想不到的情况或受到惊吓时，它会一动不动，是为了不吸引任何注意，与此同时也在思考解决问题的最好办法（如果羚羊有一条技术支持热线，此时占线。）。然后，一旦它找到了最安全的行动方案，它便去做。 当程序出毛病的时候，立刻停止正在做的任何操作。不要按任何按钮。仔细地看一下屏幕，注意那些不正常的地方，记住它或者写下来。然后慎重地点击 “确定” 或“取消”，选择一个最安全的。学着养成一种条件反射——一旦电脑出了问题，先不要动。要想摆脱这个问题，关掉受影响的程序或者重新启动计算机都不好，一个解决问题的好办法是让问题再次产生。程序员们喜欢可以被重现的问题，快乐的程序员可以更快而且更有效率的修复bug。 “我想粒子的跃迁与错误的极化有关” 并不只是非专业的用户才会写出拙劣的bug报告，我见过一些非常差的bug报告出自程序员之手，有些还是非常优秀的程序员。 有一次我与另一个程序员一起工作，他一直在找代码中的bug，他常常遇到一个bug，但是不会解决，于是就叫我帮忙。“出什么毛病了？”我问。而他的回答却总是一些关于bug的意见。如果他的观点正确，那的确是一件好事。这意味着他已经完成了工作的一半，并且我们可以一起完成另一半工作。这是有效率并有用的。 但事实上他常常是错的。这就会使我们花上半个小时在原本正确的代码里来回寻找错误，而实际上问题出在别的地方。我敢肯定他不会对医生这么做。“大夫，我得了Hydroyoyodyne（真是怪病——译者），给我开个方子”，人们知道不该对一位医生说这些。您描述一下症状，哪个地方不舒服，哪里疼、起皮疹、发烧……让医生诊断您得了什么病，应该怎样治疗。否则医生会把您当做疑心病或精神病患者打发了，这似乎没什么不对。 做程序员也是一样。即便您自己的“诊断”有时真的有帮助，也要只说“症状”。“诊断”是可说可不说的，但是“症状”一定要说。同样，在bug报告里面附上一份针对bug而做出修改的源代码是有用处的，但它并不能替代bug报告本身。 如果程序员向您询问额外的信息，千万别应付。曾经有一个人向我报告bug，我让他试一个命令，我知道这个命令不好用，但我是要看看程序会返回一个什么错误（这是很重要的线索）。但是这位老兄根本就没试，他在回复中说“那肯定不好用”，于是我又花了好些时间才说服他试了一下那个命令。 多动动脑筋对程序员是有帮助的。即使您的推断是错误的，程序员也应该感谢您，您的尝试使他们的工作变的更简单。不过千万别忘了报告“症状”，否则只会使事情变得更糟。 “真是奇怪，刚才还不好用，怎么现在又好了？” “间歇性错误”着实让程序员发愁。相比之下，进行一系列简单的操作便能导致错误发生的问题是简单的。程序员可以在一个便于观察的条件下重复那些操作，观察每一个细节。太多的问题在这种情况下不能解决，例如：程序每星期出一次错，或者偶然出一次错，或者在程序员面前从不出错（程序员一离开就出错。——译者）。当然还有就是程序的截止日期到了，那肯定要出错。 大多数“间歇性错误”并不是真正的“间歇”。其中的大多数错误与某些地方是有联系的。有一些错误可能是内存泄漏产生的，有一些可能是别的程序在不恰当的时候修改某个重要文件造成的，还有一些可能发生在每一个小时的前半个小时中（我确实遇到过这种事情）。 同样，如果您能使bug重现，而程序员不能，那很有可能是他们的计算机和您的计算机在某些地方是不同的，这种不同引起了问题。我曾写过一个程序，它的窗口可以蜷缩成一个小球停在屏幕的左上角，它在别的计算机上只能在800×600解析度工作，但是在我的机器上却可以在1024×768工作。 程序员想要了解任何与您发现的问题相关的事情。有可能的话您到另一台机器上试试，多试几次，两次，三次，看看问题是不是经常发生。如果问题出现在您进行了一系列操作之后，不是您想让它出现它就会出现，这就有可能是长时间的运行或处理大文件所导致的错误。程序崩溃的时候，您要尽可能的记住您都做了些什么，并且如果您看到任何图形,也别忘了提一下。您提供的任何事情都是有帮助的。即使只是概括性的描述（例如：当后台有EMACS运行时，程序常常出错），这虽然不能提供导致问题的直接线索，但是可能帮助程序员重现问题。 最重要的是：程序员想要确定他们正在处理的是一个真正的“间歇性错误”呢，还是一个在另一类特定的计算机上才出现的错误。他们想知道有关您计算机的许多细节，以便了解您的机器与他们的有什么不同。有许多细节都依仗特定的程序，但是有一件东西您一定要提供——版本号。程序的版本、操作系统的版本以及与问题有关的程序的版本。 “我把磁盘装进了我的Windows……” 表意清楚在一份bug报告里是最基本的要求。如果程序员不知道您说的是什么意思，那您就跟没说一样。我收到的bug报告来自世界各地，有许多是来自非英语国家，他们通常为自己的英文不好而表示歉意。总的来说，这些用户发来的bug报告通常是清晰而且有用的。几乎所有不清晰的bug报告都是来自母语是英语的人，他们总是以为只要自己随便说说，程序员就能明白。 精确： 如果做相同的事情有两种方法，请说明您用的是哪一种。例如：“我选择了‘载入’”，可能意味着“我用鼠标点击‘载入’”或“我按下了‘ALT+L’”，说清楚您用了哪种方法，有时候这也有关系。 详细： 信息宁多毋少！如果您说了很多，程序员可以略去一部分，可是如果您说的太少，他们就不得不回过头再去问您一些问题。有一次我收到了一份bug报告只有一句话，每一次我问他更多事情时，他每次的回复都是一句话，于是我花了几个星期的时间才得到了有用的信息。 谨慎使用代词： 诸如“它”，“窗体”这些词，当它们指代不清晰的时候不要用。来看看这句话：“我运行了FooApp，它弹出一个警告窗口，我试着关掉它，它就崩溃了。”这种表述并不清晰，用户究竟关掉了哪个窗口？是警告窗口还是整个FooApp程序？您可以这样说，“我运行FooApp程序时弹出一个警告窗口，我试着关闭警告窗口，FooApp崩溃了。”这样虽然罗嗦点，但是很清晰不容易产生误解。 检查： 重新读一遍您写的bug报告，您觉得它是否清晰？如果您列出了一系列能导致程序出错的操作，那么照着做一遍，看看您是不是漏写了一步。 小结： bug报告的首要目的是让程序员亲眼看到错误。如果您不能亲自做给他们看，给他们能使程序出错的详细的操作步骤。 如果首要目的不能达成，程序员不能看到程序出错。这就需要bug报告的第二个目的来描述程序的什么地方出毛病了。详细的描述每一件事情：您看到了什么，您想看到什么，把错误消息记下来，尤其是“错误消息号”。 当您的计算机做了什么您料想不到的事，不要动！在您平静下来之前什么都别做。不要做您认为不安全的事。 尽量试着自己“诊断”程序出错的原因（如果您认为自己可以的话）。即使做出了“诊断”，您仍然应该报告“症状”。 如果程序员需要，请准备好额外的信息。如果他们不需要，就不会问您要。他们不会故意为难自己。您手头上一定要有程序的版本号，它很可能是必需品。 表述清楚，确保您的意思不能被曲解。 总的来说，最重要的是要做到精确。程序员喜欢精确。 本文来源Copyright(C) 2001 by Eric S. Raymond中文版Copyleft 2001 by D.H.Grand(nOBODY/Ginux)英文版：http://www.tuxedo.org/~esr/faqs/smart-questions.html感谢Eric的耐心指点和同意，本文才得以完成并发布本指南英文版版权为Eric Steven Raymond 所有 中文版版权由D.H.Grand[nOBODY/Ginux]所有 附带一个好玩的小东西CNM你不会百度吗？(参数为q)]]></content>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github搭建Hexo博客]]></title>
    <url>%2F2017%2F12%2F30%2FGithubHexo%2F</url>
    <content type="text"><![CDATA[开始之前为什么要用Github搭建Hexo的博客呢？首先，省钱！作为一个学生狗，服务器支出是一笔不少的费用，虽然我现在有一台腾讯云1元的服务器，但是这台服务器还有别的用途。用Github搭建网站完全免费。除此之外，Hexo生成的是静态网站，托管在Github上，只要不是有人黑了你的Github帐号，你的网站就很安全。于是我背叛了worldpress转到了Hexo+Github上 准备 github建立Repository，名字为你的名字.github.io（如wwillv.github.io） 电脑上安装Git和Node.js(国内上不去可以用Node.js中文网) 安装 在你准备建立Hexo的位置上建立一个文件夹，如blog，cd进入该目录npm install -g hexo安装hexo 输入hexo init初始化hexo 输入hexo g(或hexo generate)生成静态页面 输入hexo s(或hexo server)启动本地服务浏览器打开localhost:4000如果你能看到这个界面说明你的hexo搭建已基本成功 此时你的hexo本地配置已基本完成，可以上传github了，但为了方便我将在本地顺便将主题和插件也一并配置结束，你可以跳过这一步骤直接到上传Github去 配置主题 主题选择，网上有很多hexo的主题，github上也有很多，我选择的是Next 大多数的主题的页面都有详细的配置教程，以Next为例 cd进入themes目录，clone仓库到next文件夹git clone https://github.com/iissnan/hexo-theme-next next 在 hexo 根目录下 的配置文件_config.yml里设置主题theme: next 根据自己需要可以继续自定义主题，next主题可以参考这篇文章 运行hexo clean，运行hexo g后运行hexo s，浏览器打开http://localhost:4000/可以看到自己的新主题的样子了 上传Github 回到主目录，安装hexo-deployer-gitnpm install hexo-deployer-git 修改blog文件夹（博客根目录）下的_config.yml，最下面的deploy:修改为如下格式 1234deploy: type: git repo: https://github.com/WWILLV/wwillv.github.io.git（这里是你的仓库地址，后面要加.git） branch: master hexo d（或hexo deploy）将网站上传至github 网站已建立完毕，访问你的名字.github.io（如wwillv.github.io）即可查看 网站备份由于hexo上传到Github上是生成的网站，源文件是不会上传的，换电脑后再移动文件很麻烦，这里推荐一个自动备份网站到Github的工具hexo-git-backup,可按照README的介绍进行安装 npm install hexo-git-backup --save安装hexo-git-backup 修改根目录的_config.yml，加入如下内容： 12345backup: type: git theme: next,landscape,xxx repository: github: git@github.com:xxx/xxx.git,branchName hexo b备份文件 获取备份12git clone git@github.com:username/username.github.io.gitgit checkout branchname 绑定域名 注册域名，腾讯云，阿里云（万网），GoDaddy什么的都可以，域名注册商有很多 一般域名注册都提供域名的解析，解析前ping一下自己的github.io ping wwillv.github.io如图所示我的IP是151.101.229.147 已腾讯云的解析为例，添加如下2条记录，1条A记录和1条CHAME记录 在Github的仓库的设置Custom domain里填入自己的域名（不建议）在Custom domain设置域名后会发现每次上传后域名都会失效，这是因为设置Custom domain会生成一个CNAME文件，上传后这个文件会被删除，所以可以在\source目录下新建一个CNAME文件。Windows不能直接生成没有后缀的文件，可以先生成一个再用move命令重命名，但这样比较麻烦。如果有touch的话可以直接在目录下执行touch CNAME命令就可以生成了。文件内只需写一行域名即可，如willv.cn。 浏览器输入自己的域名，刷新一会儿就出来了 开始第一篇文章hexo new &quot;title&quot;（或hexo n &quot;title&quot;）新建一篇文章，也可以在\source\_posts新建一个.md文件。hexo使用markdown语法，文章也是md格式。与平时的富文本的博客不同，写作需要遵循markdown的语法。删除文章直接删除对应的.md文件后hexo g重新生成一下即可。 常用hexo命令 hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 命令缩写 hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令： hexo s -g #生成并本地预览hexo d -g #生成并上传]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
</search>
