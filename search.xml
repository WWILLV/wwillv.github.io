<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CVE-2019-1388 UAC提权]]></title>
    <url>%2F2019%2F11%2F21%2FCVE-2019-1388%2F</url>
    <content type="text"><![CDATA[CVE-2019-1388CVE-2019-1388 | Windows Certificate Dialog Elevation of Privilege Vulnerability 2019年11月12日msrc发布了漏洞，官方的介绍是 An elevation of privilege vulnerability exists in the Windows Certificate Dialog when it does not properly enforce user privileges. An attacker who successfully exploited this vulnerability could run processes in an elevated context. An attacker could then install programs; view, change or delete data. To exploit this vulnerability, an attacker would first have to log on to the system. An attacker could then run a specially crafted application that could exploit the vulnerability and take control of an affected system. The security update addresses the vulnerability by ensuring Windows Certificate Dialog properly enforces user privileges. 如果 Windows 证书对话框没有正确执行用户特权，则存在特权提升漏洞。成功利用此漏洞的攻击者可以在提升的环境中运行进程。然后，攻击者可能会安装程序，查看、更改或删除数据。要利用此漏洞，攻击者首先必须以普通用户权限登录系统。然后攻击者运行一个精心调制的应用，该应用可以利用此漏洞并控制受影响的系统。该安全更新通过确保 Windows 证书对话框正确执行用户特权来解决该漏洞。 影响范围也比较广，从win7到win10，server2008到2016，如果不打补丁都有威胁。 威胁测试名单 漏洞原理此漏洞是因为 UAC（用户账户控制）机制的设定不严导致的。 默认情况下， Windows 在称为「安全桌面」的单独桌面上显示所有 UAC 提示。提示本身是由名为 consent.exe 的可执行文件生成的，该可执行文件以 NT AUTHORITY\SYSTEM 身份运行并且有 System 的完整性水平。 由于用户可以与此安全桌面的 UI 进行交互，因此有必要对 UI 进行严格限制。否则，低特权用户可能能够通过 UI 操作的路由回路以 SYSTEM 的身份执行操作。甚至看起来无害的单独 UI 功能也可能是导致任意控制的一系列操作的第一步。 另一个需要了解的东西是 OID，如果在运行一个可执行文件的时候我们触发了 UAC，在点击「展示证书发行者的详细信息」这个链接之后： 我们可以看到证书里的 Issued by（颁发者） 字段，这个字段对应的值就是 OID。 对比一下cmd的证书 到这一步，也许找不到突破口，但是如果证书对话框定义了一个Microsoft特定对象标识符（OID），值1.3.6.1.4.1.311.2.1.10。其中WinTrust.h标头将其定义为SPC_SP_AGENCY_INFO_OBJID，如果存在，则将在细节标签中显示为SpcSpAgencyInfo。该OID的语义文献很少。但是，似乎证书对话框会解析此OID的值，如果它找到有效且格式正确的数据，它将使用它来将“常规”选项卡上的“颁发者”字段呈现为超链接。 当涉及证书对话框的UAC版本时，Microsoft没有禁用此超链接，这就给了我们提权的可能。 当 OID 为超链接时，通过点击此链接会触发 consent.exe 以 SYSTEM 权限打开浏览器访问此链接，然后此浏览器就会有 SYSTEM 权限。即使该浏览器是作为SYSTEM启动的，但是它仍显示在普通桌面而不是安全桌面上。因此，只有在用户退出所有UAC对话框后，它才变得可见。因此对于攻击者来说，这具有天然的隐藏优势。通过保存该浏览页面，会弹出微软的资源管理器，在资源管理器中邮件打开 cmd.exe 程序，就会继承浏览器的 SYSTEM 权限，由此就完成了由普通用户到 NT AUTHORITY\SYSTEM 用户的提权！ 漏洞利用以 Windows 7 为例： 先检查下补丁情况： 1systeminfo&gt;snowming.txt&amp;(for %i in ( KB4525235 KB4525233) do @type micropoor.txt|@find /i &quot;%i&quot;|| @echo %i I can fuck)&amp;del /f /q /a snowming.txt 没打补丁，用户是刚刚建的普通用户。 这个漏洞利用的精髓在于运行的软件，用来触发 UAC 「安全桌面」的软件的 OID 一定要解析为超链接。这样才能触发 consent.exe 以 SYSTEM 权限打开浏览器访问这个链接。并且当然链接要能打开才行。 demo里给的文件是hhupd.exe，但是我在网上找了半天可用的版本都找不到，最后在群里要到一个可用的exe。 HHUPD.EXE 我们不需要运行这个文件，只需要唤起UAC即可。 双击打开唤起管理员验证的UAC 点超链接后就可以退出了 此时我们可以发现开启了一个IE浏览器，这里其实并不需要像其他的文章里说的那样等它把页面加载完。此时的浏览器已经是system权限了，想办法唤起资源管理器即可，我这里是 页面，另存为唤起资源管理器，然后在资源管理器里打开cmd，继承浏览器的system权限。 提权成功！ 相关研究人员也发布了一个进程链检测脚本 https://github.com/Neo23x0/sigma/blob/master/rules/windows/process_creation/win_exploit_cve_2019_1388.yml 这里有一个zerodayinitiative发表的关于利用的视频。 https://mp.weixin.qq.com/mp/readtemplate?t=pages/video_player_tmpl&amp;auto=0&amp;vid=wxv_1084758655733563392 参考资料CVE-2019-1388 | Windows Certificate Dialog Elevation of Privilege Vulnerability THANKSGIVING TREAT: EASY-AS-PIE WINDOWS 7 SECURE DESKTOP ESCALATION OF PRIVILEGE Lz1y/imggo CVE-2019-1388：通过 UAC 进行 Windows 提权 最新Windows 7安全桌面提权漏洞风险提示与过程披露 jas502n/CVE-2019-1388]]></content>
      <tags>
        <tag>技术</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过向日葵远控从任意文件读取到获取计算机系统权限]]></title>
    <url>%2F2019%2F10%2F14%2Foray-from-afr-to-getshell%2F</url>
    <content type="text"><![CDATA[0x00事情要从最近发生的一些安全事件说起。 最近TeamViewer的事闹的挺火的，起因是FireEye的一个分析APT41的PPT中提到了TeamViewer在2016年的一起事件，这张PPT被拍了下来发到了Twitter上。其实本来没什么事，首先，16年TV的那个事件也只是报纸报道，没有证据表明TV的数据收到了影响，而且，现在都9102年了，而且火眼的报告只是说了一下过去的事情来说自己多牛逼的（他说APT41是中国的，暗示中国搞过TeamViewer）。结果，深圳网警就根据这张什么都无法证明的图发了个TeamViewer被境外黑客APT41攻破有危险的公告微博，然后国内就炸了，各大公司单位纷纷禁用TeamViewer，然后深圳网警就把之前发的公告微博给删了（令人窒息的操作）。真实的开局一张图，内容全靠编系列。（TeamViewer官方和Twitter上发原图的大哥都做了澄清，TV没问题） 没有TeamViewer那用什么的。很多人就想到了国产远控向日葵，这篇文章就说一下向日葵目前存在的安全隐患。 0x01首先，我不是做二进制的，向日葵软件本身代码是否安全我不做评价，但是我发现它的软件设计存在问题。 一句话概括，就是向日葵远控配置文件包含敏感信息。 （文中测试的向日葵是最新版） 我们看一下向日葵远控的配置文件（具体的值全删掉了） 123456789101112131415161718192021222324252627282930313233343536[base]installautorun=no_window_user_pwd=config_path=tracksvr=macaddress=password=has_uu=showupdatetip=language=hostname=hostdesc=first_run=lastview=open_eyes=screenshots_path=level=levelname=levelchanel=istransfer=ismessage=expires=skin=sunlogincode=isfastcodelogin=logintype=license=licensepsw=fastcode=fastcodepsw=sunloginserver=slapiserver=remoteid=account=…… 这不是很明显有问题吗？配置文件太详细了。 配置文件就在向日葵的安装目录下，文件名是config.ini。就说两个最关键的配置：password和fastcode。这两个有多重要的，你只要知道这两个的值，如果对方的向日葵开着，你就可以直接登录上去。 0x02试一下另一个软件缺陷，就是文件查找神器EveryThing。 everything是一款非常优秀的文件查找工具，它有一个功能是搭建服务器，把文件系统索引放到服务器上。问题就是这里，他没有robots.txt文件，这就导致谷歌等搜索爬虫会爬取到开了这一功能的文件系统，相当于一个任意文件读取。 0x03后面就很简单了。在谷歌上搜到一个文件系统或者网站应用程序存在任意文件读取的漏洞，看看也没有装向日葵，读一下配置文件，如果他向日葵在线就可以直接登录了。 由于我国国情，很多人并没有独立的IP，所以谷歌能搜到的大多数都是服务器，这就很刺激了，对吧。 后面就不说了。 0x04本文只做一个新思路的分享，参考网络安全法，任何的渗透测试都需要授权。请遵纪守法。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USENIX paper 整理]]></title>
    <url>%2F2019%2F10%2F10%2FUSENIX%2F</url>
    <content type="text"><![CDATA[USENIX Security ‘19 Technical SessionsUSENIX Security ‘19 Full Proceedings (PDF, 210.5 MB) 嵌入的由官方所提供的演讲视频来自YouTube，视情况可能需要准备梯子。 内容太多了，部分内容是机器翻译。 Keynote AddressTackling the Trust and Safety Crisis 解决信任与安全危机 Alex Stamos, Adjunct Professor, Stanford University; William J. Perry Fellow, Center for International Security and Cooperation; Fellow, Hoover Institution Around the turn of the century, the technology industry faced a pretty basic problem: we had no idea how to write secure software. Every year brought the invention of completely new classes of software flaw, there was little training available in industry or the academy, and security was considered something you added with a firewall and antivirus. Twenty years have past and, while things are far from perfect, we at least have a great deal more understanding of how to address core information security risks in complex software projects. The tech industry is now facing a whole set of new issues, ones involving our inability to build products that are safe, trustworthy, and respectful of user privacy when deployed to billions globally. Unlike before, however, this is not just a computer science problem but one that crosses into the worlds of sociology, psychology, political science, and anthropology. In this talk, the speaker will draw from his deep well of experience making serious mistakes in this area to lay out some of the basic challenges facing industry and academia while humbly suggesting some possible ways forward. This time, we don’t have decades to figure out how to do better. 翻译在本世纪初，技术行业面临一个非常基本的问题：我们不知道如何编写安全的软件。每年都发明全新的软件缺陷类别，在行业或学术机构中几乎没有有用的培训，并且安全被认为是添加了防火墙和反病毒功能的东西。二十年过去了，虽然事情还远未达到完美，但我们至少对如何解决复杂软件项目中的核心信息安全风险有了更多的了解。现在，技术行业面临着一系列新问题，其中包括我们无法在全球数十亿用户面前打造出安全、值得信赖、尊重用户隐私的产品。但是，与以往不同，这不仅是计算机科学问题，而且还涉及社会学，心理学，政治学和人类学领域。在这次演讲中，演讲者将利用他在该领域犯下的严重错误的深厚经验，阐述工业界和学术界面临的一些基本挑战，同时谦虚地提出一些可能的解决方案。这次，我们没有数十年的时间去想出如何做得更好。 Wireless SecurityA Study of the Feasibility of Co-located App Attacks against BLE and a Large-Scale Analysis of the Current Application-Layer Security Landscape 蓝牙低功耗在同一点进行应用攻击的可行性研究以及当前应用层安全形势的大规模分析 Pallavi Sivakumaran and Jorge Blasco, Royal Holloway University of London Bluetooth Low Energy (BLE) is a fast-growing wireless technology with a large number of potential use cases, particularly in the IoT domain. Increasingly, these use cases require the storage of sensitive user data or critical device controls on the BLE device, as well as the access of this data by an augmentative mobile application. Uncontrolled access to such data could violate user privacy, cause a device to malfunction, or even endanger lives. The BLE standard provides security mechanisms such as pairing and bonding to protect sensitive data such that only authenticated devices can access it. In this paper we show how unauthorized co-located Android applications can access pairing-protected BLE data, without the user’s knowledge. We discuss mitigation strategies in terms of the various stakeholders involved in this ecosystem, and argue that at present, the only possible option for securing BLE data is for BLE developers to implement remedial measures in the form of application-layer security between the BLE device and the Android application. We introduce BLECryptracer, a tool for identifying the presence of such application-layer security, and present the results of a large-scale static analysis over 18,900+ BLE-enabled Android applications. Our findings indicate that over 45% of these applications do not implement measures to protect BLE data, and that cryptography is sometimes applied incorrectly in those that do. This implies that a potentially large number of corresponding BLE peripheral devices are vulnerable to unauthorized data access. 翻译蓝牙低功耗(BLE)是一种快速发展的无线技术，有大量潜在的应用前景，特别是在物联网领域。这些用例越来越需要在BLE设备上存储敏感的用户数据或关键的设备控制，以及通过增强的移动应用程序访问这些数据。不加控制地访问这些数据可能会侵犯用户隐私，导致设备故障，甚至危及生命。BLE标准提供了诸如配对和绑定等安全机制来保护敏感数据，只有经过认证的设备才能访问这些数据。在本文中，我们展示了未经授权的Android应用程序如何在用户不知情的情况下访问受配对保护的BLE数据。们从涉及此生态系统的各个利益相关方的角度讨论缓解策略，并指出，目前，保护BLE数据唯一可行的选择是让BLE开发人员以BLE设备和Android应用程序的应用层安全性形式实施补救措施。我们将介绍BLECryptracer，这是一种用于识别此类应用程序层安全性的工具，并介绍了对18,900多个启用BLE的Android应用程序进行的大规模静态分析的结果。我们的发现表明，这些应用程序中有超过45％并未实施保护BLE数据的措施，并且在那些应用程序中，加密有时会被错误地使用。这意味着大量潜在的相应BLE外围设备容易受到未经授权的数据访问的攻击。 Sivakumaran PDF View the slides The CrossPath Attack: Disrupting the SDN Control Channel via Shared Links CrossPath攻击：通过共享链接破坏SDN控制通道 Jiahao Cao, Qi Li, and Renjie Xie, Tsinghua University; Kun Sun, George Mason University; Guofei Gu, Texas A&amp;M University; Mingwei Xu and Yuan Yang, Tsinghua University Software-Defined Networking (SDN) enables network innovations with a centralized controller controlling the whole network through the control channel. Because the control channel delivers all network control traffic, its security and reliability are of great importance. For the first time in the literature, we propose the CrossPath attack that disrupts the SDN control channel by exploiting the shared links in paths of control traffic and data traffic. In this attack, crafted data traffic can implicitly disrupt the forwarding of control traffic in the shared links. As the data traffic does not enter the control channel, the attack is stealthy and cannot be easily perceived by the controller. In order to identify the target paths containing the shared links to attack, we develop a novel technique called adversarial path reconnaissance. Both theoretic analysis and experimental results demonstrate its feasibility and efficiency of identifying the target paths. We systematically study the impacts of the attack on various network applications in a real SDN testbed. Experiments show the attack significantly degrades the performance of existing network applications and causes serious network anomalies, e.g., routing blackhole, flow table resetting and even network-wide DoS. 翻译软件定义网络（SDN）通过集中控制器以控制通道来控制整个网络，从而实现网络创新。由于控制通道可提供所有网络控制流量，因此其安全性 关重要。在文献中，我们首次提出了CrossPath攻击，该攻击通过利用控制流量和数据流量路径中的共享链接来破坏SDN控制通道。在这种攻击中，精心设计的数据流量会隐式破坏共享链接中控制流量的转发。由于数据流量没有进入控制通道，因此攻击是隐蔽的，且不容易被控制器察觉。为了确定包含共享攻击链接的目标路径，我们开发了一种称为对抗路径侦察的新技术。理论分析和实验结果均表明了其确定目标路径的可行性和效率。我们在真实的SDN测试平台中系统地研究了攻击对各种网络应用程序的影响。实验表明，这种攻击会大大降低现有网络应用程序的性能，并导致严重的网络异常，例如路由黑洞，流表重置甚至整个网络范围的DoS。 Cao Paper (Prepublication) PDF Cao PDF View the slides A Billion Open Interfaces for Eve and Mallory: MitM, DoS, and Tracking Attacks on iOS and macOS Through Apple Wireless Direct Link 为Eve和Mallory提供10亿个开放接口：通过 Apple Wireless Direct Link对iOS和macOS实施中间人，拒绝服务及跟踪攻击 Milan Stute, Technische Universität Darmstadt; Sashank Narain, Northeastern University; Alex Mariotto, Alexander Heinrich, and David Kreitschmann, Technische Universität Darmstadt; Guevara Noubir, Northeastern University; Matthias Hollick, Technische Universität Darmstadt Apple Wireless Direct Link (AWDL) is a key protocol in Apple’s ecosystem used by over one billion iOS and macOS devices for device-to-device communications. AWDL is a proprietary extension of the IEEE 802.11 (Wi-Fi) standard and integrates with Bluetooth Low Energy (BLE) for providing services such as Apple AirDrop. We conduct the first security and privacy analysis of AWDL and its integration with BLE. We uncover several security and privacy vulnerabilities ranging from design flaws to implementation bugs leading to a man-in-the-middle (MitM) attack enabling stealthy modification of files transmitted via AirDrop, denial-of-service (DoS) attacks preventing communication, privacy leaks that enable user identification and long-term tracking undermining MAC address randomization, and DoS attacks enabling targeted or simultaneous crashing of all neighboring devices. The flaws span across AirDrop’s BLE discovery mechanism, AWDL synchronization, UI design, and Wi-Fi driver implementation. Our analysis is based on a combination of reverse engineering of protocols and code supported by analyzing patents. We provide proof-of-concept implementations and demonstrate that the attacks can be mounted using a low-cost ($20) micro:bit device and an off-the-shelf Wi-Fi card. We propose practical and effective countermeasures. While Apple was able to issue a fix for a DoS attack vulnerability after our responsible disclosure, the other security and privacy vulnerabilities require the redesign of some of their services. 翻译Apple Wireless Direct Link（AWDL）是苹果生态系统中的一项关键协议，超过十亿的iOS和macOS设备使用该协议进行设备到设备的通信。 AWDL是IEEE 802.11（Wi-Fi）标准的专有扩展，并与低功耗蓝牙（BLE）集成以提供Apple AirDrop等服务。我们对AWDL及其与BLE的集成进行了首次安全和隐私分析。我们发现了一些安全和隐私漏洞，从设计缺陷到实现错误，导致中间人（MitM）攻击，从而使得可以对通过AirDrop传输的文件进行秘密修改，而拒绝服务（DoS）攻击则会阻止通信，用户识别泄露隐私和长期跟踪的漏洞破坏了MAC地址随机化，而DoS攻击使所有相邻设备定向的或同时崩溃。缺陷跨越了AirDrop的BLE发现机制，AWDL同步，UI设计和Wi-Fi驱动执行。我们的分析是基于协议的逆向和通过分析专利支持的代码的结合。我们提供了概念验证的实现，并演示了可以使用低成本（$ 20）micro:bit设备和现成的Wi-Fi卡进行攻击。我们提出切实可行的对策。尽管苹果可以在我们负责任的披露后发布针对DoS攻击漏洞的修复程序，但其他安全和隐私漏洞则需要重新设计其某些服务。 Stute Paper (Prepublication) PDF Stute PDF View the slides Hiding in Plain Signal: Physical Signal Overshadowing Attack on LTE 隐藏在纯信号中：LTE上的物理信号掩盖攻击 Hojoon Yang, Sangwook Bae, Mincheol Son, Hongil Kim, Song Min Kim, and Yongdae Kim, KAIST Long-Term Evolution (LTE) communication is based on an open medium; thus, a legitimate signal can potentially be counterfeited by a malicious signal. Although most LTE signaling messages are protected from modification using cryptographic primitives, broadcast messages in LTE have never been integrity protected. In this paper, for the first time, we present a signal injection attack that exploits the fundamental weaknesses of broadcast messages in LTE and modifies a transmitted signal over the air. This attack, which is referred to as signal overshadowing (named SigOver) has several advantages and differences when compared with existing attacks using a fake base station. For example, with a 3 dB power difference from a legitimate signal, the SigOver demonstrated a 98% success rate when compared with the 80% success rate of attacks achieved using a fake base station, even with a 35 dB power difference. Given that the SigOver is a novel primitive attack, it yields five new attack scenarios and implications. Finally, a discussion on two potential countermeasures leaves practical and robust defense mechanism as a future work. 翻译长期演进（LTE）通信基于开放媒体。因此，合法信号可能会被恶意信号伪造。尽管大多数LTE信号消息都受到保护，不能使用密码原语进行修改，但LTE中的广播消息从未受到过完整性保护。在本文中，我们首次提出了一种信号注入攻击，该攻击利用LTE中广播消息的基本弱点并修改空中传输的信号。与使用伪基站的现有攻击相比，这种攻击被称为信号遮盖（称为SigOver），具有多个优点和不同之处。例如，与合法信号相比，功率差为3 dB，即使使用35 dB的功率差，SigOver的成功率为98％，而使用伪基站的攻击成功率为80％。鉴于SigOver是一种新颖的简单攻击，它会产生五个新的攻击场景和含义。最后，对两种可能的防御策略进行了讨论，把强大的防御机制做为未来的工作。 Yang PDF UWB-ED: Distance Enlargement Attack Detection in Ultra-Wideband UWB-ED：超宽带中的距离扩大攻击检测 Mridula Singh, Patrick Leu, AbdelRahman Abdou, and Srdjan Capkun, ETH Zurich Mobile autonomous systems, robots, and cyber-physical systems rely on accurate positioning information. To conduct distance-measurement, two devices exchange signals and, knowing these signals propagate at the speed of light, the time of arrival is used for distance estimations. Existing distance-measurement techniques are incapable of protecting against adversarial distance enlargement—a highly devastating tactic in which the adversary reissues a delayed version of the signals transmitted between devices, after distorting the authentic signal to prevent the receiver from identifying it. The adversary need not break crypto, nor compromise any upper-layer security protocols for mounting this attack. No known solution currently exists to protect against distance enlargement. We present \textit{Ultra-Wideband Enlargement Detection} (UWB-ED), a new modulation technique to detect distance enlargement attacks, and securely verify distances between two mutually trusted devices. We analyze UWB-ED under an adversary that injects signals to block/modify authentic signals. We show how UWB-ED is a good candidate for 802.15.4z Low Rate Pulse and the 5G standard. 翻译移动自主系统，机器人和网络物理系统依赖于准确的定位信息。为了进行距离测量，两个设备交换信号，并且知道这些信号以光速传播，因此将到达时间用于距离估计。现有的距离测量技术无法防止对抗距离的增大，这是一种极具破坏性的策略，在这种策略中，对手会在使真实信号失真之后重新发出设备之间传输的信号的延迟版本，以防止接收方对其进行识别。攻击者无需破坏加密货币，也无需破坏任何上层安全协议来发起这种攻击。当前不存在已知的解决方案以防止距离增大。我们介绍\ textit {超宽带放大检测}（UWB-ED），这是一种新的调制技术，可以检测距离扩大攻击，并安全地验证两个相互信任的设备之间的距离。我们在注入信号以阻止/修改真实信号的对手下分析UWB-ED。我们展示了UWB-ED如何成为802.15.4z低速率脉冲和5G标准的良好候选者。 Singh Paper (Prepublication) PDF Singh PDF Protecting Users EverywhereComputer Security and Privacy in the Interactions Between Victim Service Providers and Human Trafficking Survivors 受害者服务提供商与人口贩运幸存者之间的互动中的计算机安全和隐私(看不懂这个标题) Christine Chen, University of Washington; Nicola Dell, Cornell Tech; Franziska Roesner, University of Washington A victim service provider, or VSP, is a crucial partner in a human trafficking survivor’s recovery. VSPs provide or connect survivors to services such as medical care, legal services, employment opportunities, etc. In this work, we study VSP-survivor interactions from a computer security and privacy perspective. Through 17 semi-structured interviews with staff members at VSPs and survivors of trafficking, we surface the role technology plays in VSP-survivor interactions as well as related computer security and privacy concerns and mitigations. Our results highlight various tensions that VSPs must balance, including building trust with their clients (often by giving them as much autonomy as possible) while attempting to guide their use of technology to mitigate risks around revictimization. We conclude with concrete recommendations for computer security and privacy technologists who wish to partner with VSPs to support and empower trafficking survivors. 翻译受害者服务提供商（VSP）是人口贩运幸存者康复中的关键合作伙伴。 VSP为幸存者提供服务或将其连接到医疗，法律服务，就业机会等服务。在这项工作中，我们从计算机安全性和隐私性角度研究VSP幸存者之间的互动。 通过对VSP和贩运幸存者的工作人员进行的17次半结构化访谈，我们了解了技术在VSP与幸存者互动以及相关的计算机安全性和隐私问题以及缓解措施中的作用。 我们的结果强调了VSP必须平衡的各种紧张局势，包括与客户建立信任（通常是通过给予他们尽可能多的自治权），同时试图指导他们使用技术来减轻重新获得补偿的风险。 最后，我们为希望与VSP合作以支持和增强贩运幸存者能力的计算机安全和隐私技术人员提供具体建议。 Chen Paper (Prepublication) PDF Chen PDF Clinical Computer Security for Victims of Intimate Partner Violence 亲密伴侣暴力受害者的临床计算机安全 Sam Havron, Diana Freed, and Rahul Chatterjee, Cornell Tech; Damon McCoy, New York University; Nicola Dell and Thomas Ristenpart, Cornell Tech Digital insecurity in the face of targeted, persistent attacks increasingly leaves victims in debilitating or even life-threatening situations. We propose an approach to helping victims, what we call clinical computer security, and explore it in the context of intimate partner violence (IPV). IPV is widespread and abusers exploit technology to track, harass, intimidate, and otherwise harm their victims. We report on the iterative design, refinement, and deployment of a consultation service that we created to help IPV victims obtain in-person security help from a trained technologist. To do so we created and tested a range of new technical and non-technical tools that systematize the discovery and investigation of the complicated, multimodal digital attacks seen in IPV. An initial field study with 44 IPV survivors showed how our procedures and tools help victims discover account compromise, exploitable misconfigurations, and potential spyware. 翻译面对有针对性的持续攻击所面临的数字不安全状况越来越多地使受害者处于使人衰弱甚至危及生命的境地。 我们提出一种帮助受害者的方法，即所谓的临床计算机安全，并在亲密伴侣暴力（IPV）的背景下进行探讨。 IPV广泛存在，滥用者利用技术来跟踪，骚扰，恐吓或以其他方式伤害受害者。 我们报告了我们为帮助IPV受害人从训练有素的技术人员那里获得现场安全帮助而创建的咨询服务的迭代设计，完善和部署。 为此，我们创建并测试了一系列新的技术和非技术工具，这些工具将对IPV中复杂的多模式数字攻击的发现和调查系统化。 最初对44名IPV幸存者进行了现场研究，结果表明我们的程序和工具如何帮助受害者发现帐户遭到破坏，可利用的错误配置以及潜在的间谍软件。 Havron PDF Evaluating the Contextual Integrity of Privacy Regulation: Parents’ IoT Toy Privacy Norms Versus COPPA 评估隐私法规的上下文完整性：父母的物联网玩具隐私规范与COPPA Noah Apthorpe, Sarah Varghese, and Nick Feamster, Princeton University Increased concern about data privacy has prompted new and updated data protection regulations worldwide. However, there has been no rigorous way to test whether the practices mandated by these regulations actually align with the privacy norms of affected populations. Here, we demonstrate that surveys based on the theory of contextual integrity provide a quantifiable and scalable method for measuring the conformity of specific regulatory provisions to privacy norms. We apply this method to the U.S. Children’s Online Privacy Protection Act (COPPA), surveying 195 parents and providing the first data that COPPA’s mandates generally align with parents’ privacy expectations for Internet-connected “smart” children’s toys. Nevertheless, variations in the acceptability of data collection across specific smart toys, information types, parent ages, and other conditions emphasize the importance of detailed contextual factors to privacy norms, which may not be adequately captured by COPPA. 翻译对数据隐私的日益关注促使世界各地出现了新的和更新的数据保护法规。 但是，没有严格的方法来测试这些法规所要求的实践是否确实符合受影响人群的隐私规范。 在这里，我们证明了基于上下文完整性理论的调查提供了一种可量化和可扩展的方法，用于测量特定法规条款对隐私规范的符合性。 我们将此方法应用于《美国儿童在线隐私保护法》（COPPA），调查了195个父母，并提供了COPPA的授权通常与父母对互联网连接的“智能”儿童玩具的隐私期望相一致的第一批数据。 然而，跨特定智能玩具，信息类型，父母年龄和其他条件的数据收集的可接受性差异，突显了详细的上下文因素对隐私规范的重要性，COPPA可能无法充分体现这一点。 Apthorpe Paper (Prepublication) PDF Apthorpe PDF Secure Multi-User Content Sharing for Augmented Reality Applications 增强现实应用程序的安全多用户内容共享 Kimberly Ruth, Tadayoshi Kohno, and Franziska Roesner, University of Washington Augmented reality (AR), which overlays virtual content on top of the user’s perception of the real world, has now begun to enter the consumer market. Besides smartphone platforms, early-stage head-mounted displays such as the Microsoft HoloLens are under active development. Many compelling uses of these technologies are multi-user: e.g., in-person collaborative tools, multiplayer gaming, and telepresence. While prior work on AR security and privacy has studied potential risks from AR applications, new risks will also arise among multiple human users. In this work, we explore the challenges that arise in designing secure and private content sharing for multi-user AR. We analyze representative application case studies and systematize design goals for security and functionality that a multi-user AR platform should support. We design an AR content sharing control module that achieves these goals and build a prototype implementation (ShareAR) for the HoloLens. This work builds foundations for secure and private multi-user AR interactions. 翻译将虚拟内容叠加在用户对现实世界的感知之上的增强现实（AR）现在已经开始进入消费市场。除智能手机平台外，诸如Microsoft HoloLens的早期头戴式显示器也在积极开发中。这些技术有许多引人注目的用途是多用户：例如，面对面的协作工具，多人游戏和网真。尽管先前有关AR安全性和隐私的工作已经研究了AR应用程序带来的潜在风险，但多个人类用户之间也会出现新的风险。在这项工作中，我们探索了为多用户AR设计安全和私有内容共享时出现的挑战。我们分析了代表性的应用案例研究，并将多用户AR平台应支持的安全性和功能性设计目标系统化。我们设计了实现这些目标的AR内容共享控制模块，并为HoloLens构建了原型实现（ShareAR）。这项工作为安全和私有的多用户AR交互奠定了基础。 Ruth PDF View the slides Understanding and Improving Security and Privacy in Multi-User Smart Homes: A Design Exploration and In-Home User Study 了解和改善多用户智能家居中的安全性和隐私性：设计探索和家庭用户研究 Eric Zeng and Franziska Roesner, University of Washington Smart homes face unique security, privacy, and usability challenges because they are multi-user, multi-device systems that affect the physical environment of all inhabitants of the home. Current smart home technology is often not well designed for multiple users, sometimes lacking basic access control and other affordances for making the system intelligible and accessible for all users. While prior work has shed light on the problems and needs of smart home users, it is not obvious how to design and build solutions. Such questions have certainly not been answered for challenging adversarial situations (e.g., domestic abuse), but we observe that they have not even been answered for tensions in otherwise functional, non-adversarial households. In this work, we explore user behaviors, needs, and possible solutions to multi-user security and privacy issues in generally non-adversarial smart homes. Based on design principles grounded in prior work, we built a prototype smart home app that includes concrete features such as location-based access controls, supervisory access controls, and activity notifications, and we tested our prototype though a month-long in-home user study with seven households. From the results of the user study, we re-evaluate our initial design principles, we surface user feedback on security and privacy features, and we identify challenges and recommendations for smart home designers and researchers. 翻译智能家居面临着独特的安全性，隐私和可用性挑战，因为它们是影响用户所有居民物理环境的多用户，多设备系统。当前的智能家居技术通常不适用于多个用户，有时缺乏基本的访问控制和其他功能，无法使所有用户都能理解该系统。尽管先前的工作揭示了智能家居用户的问题和需求，但如何设计和构建解决方案却并不明显。对于具有挑战性的对抗性情况（例如家庭虐待），当然没有回答过这些问题，但是我们观察到，对于在其他情况下没有对抗性的家庭中的紧张局势，甚至没有回答这些问题。在这项工作中，我们探讨了用户行为，需求以及可能在一般非对抗性智能家居中解决多用户安全和隐私问题的解决方案。基于先前工作的设计原则，我们构建了一个原型智能家居应用程序，其中包含诸如基于位置的访问控制，监管访问控制和活动通知之类的具体功能，并且我们通过一个月的家庭用户对我们的原型进行了测试与七个家庭一起学习。根据用户研究的结果，我们重新评估了我们的初始设计原则，我们在安全性和隐私功能方面获得了用户反馈，并为智能家居设计师和研究人员确定了挑战和建议。 Zeng PDF Invited TalksEmbracing the “Hack.” A Better Strategy for Team-Defense 拥抱“黑客”。 更好的团队防守策略 Haroon Meer, Founder of Thinkst Applied Research This talk suggests that custom detection and response capabilities are a key component for enterprise defense. It posits that maybe, defense needs to take a step back and embrace “hackyness” to prevail. Historically, offense has embraced “hacky solutions” while team-Defense has often shied away from them. We argue that this delta, on a fluid battlefield, gives attackers a distinct advantage and we suggest it is time for this to change. Using the free Canarytokens service as a lens, we will step through several examples of these “hacks” and will explain how they (and the thinking behind them) can lead to safer enterprises and networks. We also hope to identify areas we believe are ripe for deeper technical dives and ongoing research efforts. 翻译该演讲表明，自定义检测和响应功能是企业防御的关键组成部分。 它认为，防御可能需要退后一步，接受“ hackyness”才能取得胜利。从历史上看，进攻是采用“ hacky解决方案”，而防卫队经常躲避它们。 我们认为，在变化多端的战场上，这种变化为攻击者提供了明显的优势，我们建议现在是时候对此进行改变。我们将以免费的Canarytokens服务作为一个镜头，逐步介绍这些“黑客”的几个例子，并说明它们（及其背后的思想）如何导致更安全的企业和网络。 我们还希望确定我们认为更深层次的技术探索和正在进行的研究工作已经成熟的领域。 Evaluating Mobile Messengers for Implementation Vulnerabilities 评估移动信使的实施漏洞 Natalie Silvanovich, Security Engineer, Google Mobile Messaging applications are a valuable target for attackers because vulnerabilities in these applications have the potential to allow a mobile device to be compromised without any user interaction. This talk describes Project Zero’s work evaluating mobile messaging applications for security-impacting bugs. It will share techniques for finding vulnerabilities in mobile applications and give some examples of the bugs discovered using them. It will also explain how design and development decisions impacted the frequency and severity of these vulnerabilities. It will then discuss the importance of considering implementation in design, and how academic researchers can give more consideration to the implementation aspects of new technologies. 翻译移动消息传递应用程序是攻击者的重要目标，因为这些应用程序中的漏洞有可能允许在没有任何用户交互的情况下破坏移动设备。 这篇演讲描述了零号项目评估移动消息传递应用程序中是否有影响安全的bug的工作。 它将分享在移动应用程序中查找漏洞的技术，并提供一些使用它们发现的错误的示例。 它还将说明设计和开发决策如何影响这些漏洞的频率和严重性。 然后，它将讨论在设计中考虑实施的重要性，以及学术研究人员如何才能更多地考虑新技术的实施方面。 Hardware SecurityPAC it up: Towards Pointer Integrity using ARM Pointer Authentication PAC it up:使用ARM指针身份验证实现指针完整性 Hans Liljestrand, Aalto University, Huawei Technologies Oy; Thomas Nyman, Aalto University; Kui Wang, Huawei Technologies Oy, Tampere University of Technology; Carlos Chinea Perez, Huawei Technologies Oy; Jan-Erik Ekberg, Huawei Technologies Oy, Aalto University; N. Asokan, Aalto University Run-time attacks against programs written in memory-unsafe programming languages (e.g., C and C++) remain a prominent threat against computer systems. The prevalence of techniques like return-oriented programming (ROP) in attacking real-world systems has prompted major processor manufacturers to design hardware-based countermeasures against specific classes of run-time attacks. An example is the recently added support for pointer authentication (PA) in the ARMv8-A processor architecture, commonly used in devices like smartphones. PA is a low-cost technique to authenticate pointers so as to resist memory vulnerabilities. It has been shown to enable practical protection against memory vulnerabilities that corrupt return addresses or function pointers. However, so far, PA has received very little attention as a general purpose protection mechanism to harden software against various classes of memory attacks. In this paper, we use PA to build novel defenses against various classes of run-time attacks, including the first PA-based mechanism for data pointer integrity. We present PARTS, an instrumentation framework that integrates our PA-based defenses into the LLVM compiler and the GNU/Linux operating system and show, via systematic evaluation, that PARTS provides better protection than current solutions at a reasonable performance overhead. 翻译对以不安全内存的编程语言（例如C和C ++）编写的程序的运行时攻击仍然是对计算机系统的主要威胁。在攻击真实世界的系统中，诸如面向返回的编程（ROP）之类的技术非常流行，促使主要的处理器制造商设计针对特定类型的运行时攻击的基于硬件的对策。一个示例是最近在ARMv8-A处理器体系结构中添加的对指针身份验证（PA）的支持，该体系结构通常在智能手机等设备中使用。 PA是一种低成本的身份验证指针技术，可以抵抗内存漏洞。它显示出可以针对损坏返回地址或函数指针的内存漏洞提供切实的保护。但是，到目前为止，PA作为用于保护软件以抵抗各种类型的内存攻击的通用保护机制，很少受到关注。在本文中，我们使用PA构建针对各种类型的运行时攻击的新颖防御措施，包括第一个基于PA的数据指针完整性机制。我们介绍PARTS，这是一种仪器框架，将基于PA的防御功能集成到LLVM编译器和GNU / Linux操作系统中，并通过系统评估显示，PARTS在合理的性能开销下提供了比当前解决方案更好的保护。 Liljestrand Paper (Prepublication) PDF Liljestrand PDF View the slides Origin-sensitive Control Flow Integrity 源敏感的控制流完整性 Mustakimur Rahman Khandaker, Wenqing Liu, Abu Naser, Zhi Wang, and Jie Yang, Florida State University CFI is an effective, generic defense against control-flow hijacking attacks, especially for C/C++ programs. However, most previous CFI systems have poor security as demonstrated by their large equivalence class (EC) sizes. An EC is a set of targets that are indistinguishable from each other in the CFI policy; i.e., an attacker can “bend”‘ the control flow within an EC without being detected. As such, the large ECs denote the weakest link in a CFI system and should be broken down in order to improve security. An approach to improve the security of CFI is to use contextual information, such as the last branches taken, to refine the CFI policy, the so-called context-sensitive CFI. However, contexts based on the recent execution history are often inadequate in breaking down large ECs due to the limited number of incoming execution paths to an indirect control transfer instruction (ICT). In this paper, we propose a new context for CFI, origin sensitivity, that can effectively break down large ECs and reduce the average and largest EC size. Origin-sensitive CFI (OS-CFI) takes the origin of the code pointer called by an ICT as the context and constrains the targets of the ICT with this context. It supports both C-style indirect calls and C++ virtual calls. Additionally, we leverage common hardware features in the commodity Intel processors (MPX and TSX) to improve both security and performance of OS-CFI. Our evaluation shows that OS-CFI can substantially reduce the largest and average EC sizes (by 98% in some cases) and has strong performance – 7.6% overhead on average for all C/C++ benchmarks of SPEC CPU2006 and NGINX. 翻译CFI是针对控制流劫持攻击的有效，通用防御，尤其是对于C / C ++程序而言。但是，大多数以前的CFI系统的安全性很差，这由其较大的等价类（EC）规模证明。 EC是CFI政策中彼此无法区分的一组目标。也就是说，攻击者可以在不被检测到的情况下“弯曲” EC中的控制流。因此，大型EC表示CFI系统中最薄弱的环节，应该对其进行分解以提高安全性。一种提高CFI安全性的方法是使用上下文信息（例如最近采用的分支）来完善CFI策略，即上下文相关的CFI。但是，由于到间接控制转移指令（ICT）的传入执行路径数量有限，因此基于最近执行历史的上下文通常不足以分解大型EC。在本文中，我们提出了CFI的新背景，即起源敏感性，可以有效地分解大型EC，并减小平均和最大EC大小。起源敏感的CFI（OS-CFI）将ICT调用的代码指针的起源作为上下文，并在此上下文中约束ICT的目标。它支持C风格的间接调用和C ++虚拟调用。此外，我们利用商用英特尔处理器（MPX和TSX）中的通用硬件功能来提高OS-CFI的安全性和性能。我们的评估表明，OS-CFI可以显着减小最大和平均EC大小（在某些情况下减少98％），并具有强大的性能-SPEC CPU2006和NGINX的所有C / C ++基准平均开销为7.6％。 Khandaker PDF View the slides HardFails: Insights into Software-Exploitable Hardware Bugs HardFails：洞察软件可利用的硬件错误 Ghada Dessouky and David Gens, Technische Universität Darmstadt; Patrick Haney and Garrett Persyn, Texas A&amp;M University; Arun Kanuparthi, Hareesh Khattri, and Jason M. Fung, Intel Corporation; Ahmad-Reza Sadeghi, Technische Universität Darmstadt; Jeyavijayan Rajendran, Texas A&amp;M University Modern computer systems are becoming faster, more efficient, and increasingly interconnected with each generation. Thus, these platforms grow more complex, with new features continually introducing the possibility of new bugs. Although the semiconductor industry employs a combination of different verification techniques to ensure the security of System-on-Chip (SoC) designs, a growing number of increasingly sophisticated attacks are starting to leverage cross-layer bugs. These attacks leverage subtle interactions between hardware and software, as recently demonstrated through a series of real-world exploits that affected all major hardware vendors. In this paper, we take a deep dive into microarchitectural security from a hardware designer’s perspective by reviewing state-of-the-art approaches used to detect hardware vulnerabilities at design time. We show that a protection gap currently exists, leaving chip designs vulnerable to software-based attacks that can exploit these hardware vulnerabilities. Inspired by real-world vulnerabilities and insights from our industry collaborator (a leading chip manufacturer), we construct the first representative testbed of real-world software-exploitable RTL bugs based on RISC-V SoCs. Patching these bugs may not always be possible and can potentially result in a product recall. Based on our testbed, we conduct two extensive case studies to analyze the effectiveness of state-of-the-art security verification approaches and identify specific classes of vulnerabilities, which we call HardFails, which these approaches fail to detect. Through our work, we focus the spotlight on specific limitations of these approaches to propel future research in these directions. We envision our RISC-V testbed of RTL bugs providing a rich exploratory ground for future research in hardware security verification and contributing to the open-source hardware landscape. 翻译现代计算机系统正变得越来越快，越来越高效，并且与每一代人的联系越来越紧密。因此，这些平台变得越来越复杂，新功能不断引入新错误的可能性。尽管半导体行业采用各种不同的验证技术来确保片上系统（SoC）设计的安全性，但是越来越多的越来越复杂的攻击开始利用跨层错误。这些攻击利用了硬件和软件之间的微妙交互，最近通过一系列影响所有主要硬件供应商的实际攻击证明了这一点。在本文中，我们将从硬件设计者的角度深入研究微体系结构安全性，方法是回顾在设计时用于检测硬件漏洞的最新方法。我们表明，目前存在保护缺口，使芯片设计容易受到可利用这些硬件漏洞的基于软件的攻击。受现实漏洞和行业合作伙伴（领先的芯片制造商）的启发，我们构建了基于RISC-V SoC的第一个具有代表性的真实世界软件可利用RTL错误测试平台。修补这些错误并非总是可能的，并且可能导致产品召回。基于我们的测试平台，我们进行了两个广泛的案例研究，以分析最新安全验证方法的有效性，并确定这些方法无法检测到的特定类别的漏洞（我们称为HardFails）。通过我们的工作，我们将注意力集中在这些方法的特定局限性上，以推动这些方向的未来研究。我们设想我们的RTL错误的RISC-V测试平台将为硬件安全验证的未来研究提供丰富的探索性基础，并有助于开源硬件的发展。 Dessouky PDF uXOM: Efficient eXecute-Only Memory on ARM Cortex-M uXOM：基于ARM Cortex-M的高效只执行内存 Donghyun Kwon, Jangseop Shin, and Giyeol Kim, Seoul National University; Byoungyoung Lee, Seoul National University, Purdue University; Yeongpil Cho, Soongsil University; Yunheung Paek, Seoul National University Code disclosure attacks are one of the major threats to a computer system, considering that code often contains security sensitive information, such as intellectual properties (e.g., secret algorithm), sensitive data (e.g., cryptographic keys) and the gadgets for launching code reuse attacks. To stymie this class of attacks, security researchers have devised a strong memory protection mechanism, called eXecute-Only-Memory (XOM), that defines special memory regions where instruction execution is permitted but data reads and writes are prohibited. Reflecting the value of XOM, many recent high-end processors have added support for XOM in their hardware. Unfortunately, however, low-end embedded processors have yet to provide hardware support for XOM. In this paper, we propose a novel technique, named uXOM, that realizes XOM in a way that is secure and highly optimized to work on Cortex-M, which is a prominent processor series used in low-end embedded devices. uXOM achieves its security and efficiency by using special architectural features in Cortex-M: unprivileged memory instructions and an MPU. We present several challenges in making XOM non-bypassable under strong attackers and introduce our code analysis and instrumentation to solve these challenges. Our evaluation reveals that uXOM successfully realizes XOM in Cortex-M processor with much better efficiency in terms of execution time, code size and energy consumption compared to a software-only XOM implementation for Cortex-M. 翻译考虑到代码通常包含对安全敏感的信息，例如知识产权（例如，秘密算法），敏感数据（例如，加密密钥）和用于发起代码重用攻击的小工具，因此代码公开攻击是对计算机系统的主要威胁之一。 。为了阻止此类攻击，安全研究人员设计了一种强大的内存保护机制，称为eXecute-Only-Memory（XOM），该机制定义了允许执行指令但禁止数据读写的特殊内存区域。反映XOM的价值，许多最新的高端处理器在其硬件中增加了对XOM的支持。但是，不幸的是，低端嵌入式处理器尚未为XOM提供硬件支持。在本文中，我们提出了一种名为uXOM的新颖技术，该技术以一种安全且经过高度优化的方式实现XOM以在Cortex-M上工作，Cortex-M是在低端嵌入式设备中使用的著名处理器系列。 uXOM通过使用Cortex-M中的特殊架构功能（无特权的内存指令和MPU）来实现其安全性和效率。在使XOM在强大的攻击者下不可旁路时，我们提出了一些挑战，并介绍了我们的代码分析和工具来解决这些挑战。我们的评估表明，与仅针对Cortex-M的软件XOM实现相比，uXOM在执行时间，代码大小和能耗方面以更高的效率成功地在Cortex-M处理器中成功实现了XOM。 Kwon PDF USENIX Security ‘19 Errata Slip View the slides A Systematic Evaluation of Transient Execution Attacks and Defenses 瞬时执行攻击和防御的系统评价 Claudio Canella, Graz University of Technology; Jo Van Bulck, imec-DistriNet, KU Leuven; Michael Schwarz, Moritz Lipp, Benjamin von Berg, and Philipp Ortner, Graz University of Technology; Frank Piessens, imec-DistriNet, KU Leuven; Dmitry Evtyushkin, College of William and Mary; Daniel Gruss, Graz University of Technology Research on transient execution attacks including Spectre and Meltdown showed that exception or branch misprediction events might leave secret-dependent traces in the CPU’s microarchitectural state. This observation led to a proliferation of new Spectre and Meltdown attack variants and even more ad-hoc defenses (e.g., microcode and software patches). Both the industry and academia are now focusing on finding effective defenses for known issues. However, we only have limited insight on residual attack surface and the completeness of the proposed defenses. In this paper, we present a systematization of transient execution attacks. Our systematization uncovers 6 (new) transient execution attacks that have been overlooked and not been investigated so far: 2 new exploitable Meltdown effects: Meltdown-PK (Protection Key Bypass) on Intel, and Meltdown-BND (Bounds Check Bypass) on Intel and AMD; and 4 new Spectre mistraining strategies. We evaluate the attacks in our classification tree through proof-of-concept implementations on 3 major CPU vendors (Intel, AMD, ARM). Our systematization yields a more complete picture of the attack surface and allows for a more systematic evaluation of defenses. Through this systematic evaluation, we discover that most defenses, including deployed ones, cannot fully mitigate all attack variants. 翻译对包括Spectre和Meltdown在内的瞬态执行攻击的研究表明，异常或分支错误预测事件可能会在CPU的微体系结构状态中留下依赖于秘密的跟踪。这种观察导致了新的Spectre和Meltdown攻击变体的泛滥，甚至出现了更多的临时防御（例如，微代码和软件补丁）。业界和学术界现在都在致力于为已知问题找到有效的防御措施。但是，我们对残余攻击面和拟议防御的完整性了解不足。在本文中，我们提出了瞬时执行攻击的系统化。我们的系统化过程发现了6个（新的）暂时执行攻击，这些攻击到目前为止都没有被忽视，并且尚未得到调查：2种新的可利用的Meltdown效果：Intel上的Meltdown-PK（保护密钥绕过），Intel和上一代的Meltdown-BND（边界检查绕过） AMD;和4种新的Spectre错误训练策略我们通过在3个主要CPU供应商（英特尔，AMD，ARM）上进行的概念验证实施，评估分类树中的攻击。我们的系统化可以对攻击面进行更全面的描述，并可以对防御进行更系统的评估。通过这种系统的评估，我们发现大多数防御措施（包括已部署的防御措施）无法完全缓解所有攻击变型。 Canella PDF View the slides Machine Learning ApplicationsThe Secret Sharer: Evaluating and Testing Unintended Memorization in Neural Networks 秘密共享者：评估和测试神经网络中的意外记忆 Nicholas Carlini, Google Brain; Chang Liu, University of California, Berkeley; Úlfar Erlingsson, Google Brain; Jernej Kos, National University of Singapore; Dawn Song, University of California, Berkeley This paper describes a testing methodology for quantitatively assessing the risk that rare or unique training-data sequences are unintentionally memorized by generative sequence models—a common type of machine-learning model. Because such models are sometimes trained on sensitive data (e.g., the text of users’ private messages), this methodology can benefit privacy by allowing deep-learning practitioners to select means of training that minimize such memorization. In experiments, we show that unintended memorization is a persistent, hard-to-avoid issue that can have serious consequences. Specifically, for models trained without consideration of memorization, we describe new, efficient procedures that can extract unique, secret sequences, such as credit card numbers. We show that our testing strategy is a practical and easy-to-use first line of defense, e.g., by describing its application to quantitatively limit data exposure in Google’s Smart Compose, a commercial text-completion neural network trained on millions of users’ email messages. 翻译本文介绍了一种测试方法，用于定量评估生成序列模型（一种常见的机器学习模型）无意中记住了稀有或唯一训练数据序列的风险。由于此类模型有时会在敏感数据（例如，用户私人消息的文本）上进行训练，因此该方法可通过允许深度学习的从业人员选择使这种记忆最小化的训练手段来保护隐私。在实验中，我们表明意外记忆是一个持续存在的，难以避免的问题，可能会造成严重后果。具体来说，对于不考虑记忆而训练的模型，我们描述了可以提取独特的秘密序列（例如信用卡号）的新型高效程序。我们证明了我们的测试策略是实用且易于使用的第一道防线，例如，通过描述其用于定量限制Google的Smart Compose中的数据暴露的应用，Smart Compose是一种以数百万用户的电子邮件进行训练的商业文本完成神经网络消息。 Carlini PDF Improving Robustness of ML Classifiers against Realizable Evasion Attacks Using Conserved Features 使用保守功能提高ML分类器针对可实现的逃逸攻击的鲁棒性 Liang Tong, Washington University in St. Louis; Bo Li, UIUC; Chen Hajaj, Ariel University; Chaowei Xiao, University of Michigan; Ning Zhang and Yevgeniy Vorobeychik, Washington University in St. Louis Machine learning (ML) techniques are increasingly common in security applications, such as malware and intrusion detection. However, ML models are often susceptible to evasion attacks, in which an adversary makes changes to the input (such as malware) in order to avoid being detected. A conventional approach to evaluate ML robustness to such attacks, as well as to design robust ML, is by considering simplified feature-space models of attacks, where the attacker changes ML features directly to effect evasion, while minimizing or constraining the magnitude of this change. We investigate the effectiveness of this approach to designing robust ML in the face of attacks that can be realized in actual malware (realizable attacks). We demonstrate that in the context of structure-based PDF malware detection, such techniques appear to have limited effectiveness, but they are effective with content-based detectors. In either case, we show that augmenting the feature space models with conserved features (those that cannot be unilaterally modified without compromising malicious functionality) significantly improves performance. Finally, we show that feature space models enable generalized robustness when faced with a variety of realizable attacks, as compared to classifiers which are tuned to be robust to a specific realizable attack. 翻译机器学习（ML）技术在安全应用程序中越来越普遍，例如恶意软件和入侵检测。但是，ML模型通常容易受到规避攻击，在这种攻击中，对手会对输入（例如恶意软件）进行更改，以避免被检测到。评估ML对此类攻击的鲁棒性以及设计鲁棒ML的常规方法是考虑简化的攻击特征空间模型，其中攻击者直接更改ML特征以进行规避，同时最小化或限制这种变化的幅度。面对可以在实际恶意软件中实现的攻击（可实现的攻击），我们研究了这种设计健壮ML的方法的有效性。我们证明，在基于结构的PDF恶意软件检测的背景下，此类技术的有效性似乎有限，但对于基于内容的检测器却有效。无论哪种情况，我们都表明，使用保守的特征（不能在不损害恶意功能的情况下不能单方面修改的特征）扩展特征空间模型，可以显着提高性能。最后，我们证明，与分类器相比，特征空间模型在面对各种可实现的攻击时具有广泛的鲁棒性，而分类器的分类器对特定的可实现的攻击具有鲁棒性。 Tong PDF View the slides ALOHA: Auxiliary Loss Optimization for Hypothesis Augmentation ALOHA：假设增加的辅助损失优化 Ethan M. Rudd, Felipe N. Ducau, Cody Wild, Konstantin Berlin, and Richard Harang, Sophos Malware detection is a popular application of Machine Learning for Information Security (ML-Sec), in which an ML classifier is trained to predict whether a given file is malware or benignware. Parameters of this classifier are typically optimized such that outputs from the model over a set of input samples most closely match the samples’ true malicious/benign (1/0) target labels. However, there are often a number of other sources of contextual metadata for each malware sample, beyond an aggregate malicious/benign label, including multiple labeling sources and malware type information (e.g. ransomware, trojan, etc.), which we can feed to the classifier as auxiliary prediction targets. In this work, we fit deep neural networks to multiple additional targets derived from metadata in a threat intelligence feed for Portable Executable (PE) malware and benignware, including a multi-source malicious/benign loss, a count loss on multi-source detections, and a semantic malware attribute tag loss. We find that incorporating multiple auxiliary loss terms yields a marked improvement in performance on the main detection task. We also demonstrate that these gains likely stem from a more informed neural network representation and are not due to a regularization artifact of multi-target learning. Our auxiliary loss architecture yields a significant reduction in detection error rate (false negatives) of 42.6% at a false positive rate (FPR) of 10-3 when compared to a similar model with only one target, and a decrease of 53.8% at 10-5 FPR. 翻译恶意软件检测是机器学习在信息安全(ML- sec)中的一个流行应用，其中一个ML分类器被训练来预测给定的文件是恶意软件还是恶意软件。该分类器的参数通常经过优化，使模型在一组输入样本上的输出最接近样本的真正恶意/良性(1/0)目标标签。然而，对于每个恶意软件样本，除了一个聚合的恶意/良性标签之外，通常还有许多其他的上下文元数据来源，包括多个标签来源和恶意软件类型信息(例如，勒索软件、木马等)，我们可以将这些信息作为辅助预测目标提供给分类器。在这项工作中，我们将深度神经网络与可移植可执行恶意软件和善意软件威胁情报源中的元数据衍生的多个附加目标相匹配，包括多源恶意/善意损失、多源检测计数损失和语义恶意软件属性标签损失。我们发现，在主检测任务中加入多个辅助损耗项可以显著提高性能。我们也证明这些增益可能来自于一个更有信息的神经网络表示，而不是由于多目标学习的正则化伪迹。与只有一个靶点的类似模型相比，我们的辅助损失架构可显著降低检测错误率(假阴性)42.6%，假阳性率(FPR)为10-3，并在10-5 FPR时降低53.8%。 Rudd PDF Why Do Adversarial Attacks Transfer? Explaining Transferability of Evasion and Poisoning Attacks 为什么对抗攻击会转移？ 解释逃逸和投毒攻击的可转移性 Ambra Demontis, Marco Melis, and Maura Pintor, University of Cagliari, Italy; Matthew Jagielski, Northeastern University; Battista Biggio, University of Cagliari, Italy, and Pluribus One; Alina Oprea and Cristina Nita-Rotaru, Northeastern University; Fabio Roli, University of Cagliari, Italy, and Pluribus One Transferability captures the ability of an attack against a machine-learning model to be effective against a different, potentially unknown, model. Empirical evidence for transferability has been shown in previous work, but the underlying reasons why an attack transfers or not are not yet well understood. In this paper, we present a comprehensive analysis aimed to investigate the transferability of both test-time evasion and training-time poisoning attacks. We provide a unifying optimization framework for evasion and poisoning attacks, and a formal definition of transferability of such attacks. We highlight two main factors contributing to attack transferability: the intrinsic adversarial vulnerability of the target model, and the complexity of the surrogate model used to optimize the attack. Based on these insights, we define three metrics that impact an attack’s transferability. Interestingly, our results derived from theoretical analysis hold for both evasion and poisoning attacks, and are confirmed experimentally using a wide range of linear and non-linear classifiers and datasets. 翻译可转移性捕获了针对机器学习模型的攻击针对不同的，可能未知的模型有效的能力。在先前的工作中已经显示了可转移性的经验证据，但是对于攻击转移与否的根本原因尚不十分了解。在本文中，我们提出了一项综合分析，旨在调查测试时间规避和训练时间中毒攻击的可转移性。我们为逃避和中毒攻击提供了统一的优化框架，并为此类攻击的可转移性提供了正式定义。我们重点介绍了有助于攻击转移的两个主要因素：目标模型的固有对抗性脆弱性以及用于优化攻击的替代模型的复杂性。基于这些见解，我们定义了三个影响攻击可传递性的指标。有趣的是，我们从理论分析得出的结果适用于躲避和中毒攻击，并使用各种线性和非线性分类器和数据集进行了实验验证。 Demontis PDF View the slides Stack Overflow Considered Helpful! Deep Learning Security Nudges Towards Stronger Cryptography Stack Overflow 是有帮助的！ 深度学习安全推动更强大的密码学 Felix Fischer, Technical University of Munich; Huang Xiao, Bosch Center for Artificial Intelligence; Ching-Yu Kao, Fraunhofer AISEC; Yannick Stachelscheid, Benjamin Johnson, and Danial Raza, Technical University of Munich; Paul Fawkesley and Nat Buckley, Projects by IF; Konstantin Böttinger, Fraunhofer AISEC; Paul Muntean and Jens Grossklags, Technical University of Munich Stack Overflow is the most popular discussion platform for software developers. Recent research found a large amount of insecure encryption code in production systems that has been inspired by examples given on Stack Overflow. By copying and pasting functional code, developers introduced exploitable software vulnerabilities into security-sensitive high-profile applications installed by millions of users every day. Proposed mitigations of this problem suffer from usability flaws and push developers to continue shopping for code examples on Stack Overflow once again. This points us to fighting the proliferation of insecure code directly at the root before it even reaches the clipboard. By viewing Stack Overflow as a market, implementation of cryptography becomes a decision-making problem: i. e. how to simplify the selection of helpful and secure examples. We focus on supporting software developers in making better decisions by applying nudges, a concept borrowed from behavioral science. This approach is motivated by one of our key findings: for 99.37% of insecure code examples on Stack Overflow, similar alternatives are available that serve the same use case and provide strong cryptography. Our system design is based on several nudges that are controlled by a deep neural network. It learns a representation for cryptographic API usage patterns and classification of their security, achieving average AUC-ROC of 0.992. With a user study we demonstrate that nudge-based security advice significantly helps tackling the most popular and error-prone cryptographic use cases in Android. 翻译Stack Overflow是软件开发人员最受欢迎的讨论平台。最近的研究发现生产系统中存在大量不安全的加密代码，这是受Stack Overflow上的示例启发的。通过复制和粘贴功能代码，开发人员将可利用的软件漏洞引入了每天由数百万用户安装的对安全敏感的，备受关注的应用程序中。建议缓解此问题的方法存在可用性缺陷，并促使开发人员再次在Stack Overflow上再次购买代码示例。这表明我们要在不安全代码甚至到达剪贴板之前就直接在根源处进行对抗。通过将Stack Overflow视为一个市场，密码学的实施成为一个决策问题： e。如何简化对有用和安全示例的选择。我们专注于支持软件开发人员通过应用微调做出更好的决策，这种微调是从行为科学中借鉴来的。这种方法是由我们的一项主要发现所激发的：对于Stack Overflow上99.37％的不安全代码示例，可以使用类似的替代方法来服务相同的用例并提供强大的加密技术。我们的系统设计基于由深度神经网络控制的多个微调。它学习了加密API使用模式的表示形式及其安全性分类，从而实现了0.992的平均AUC-ROC。通过一项用户研究，我们证明了基于轻推的安全建议可以极大地帮助解决Android中最流行且易于出错的加密用例。 Fischer Paper (Prepublication) PDF Fischer PDF 后面的暂缓更新]]></content>
      <tags>
        <tag>安全</tag>
        <tag>科研</tag>
        <tag>论文</tag>
        <tag>335</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[续·终物语]]></title>
    <url>%2F2019%2F04%2F08%2FZokuOwarimonogatari%2F</url>
    <content type="text"><![CDATA[什么嘛 这种事情而已如果不知道前行时是先迈出右脚还是左脚的话这样做不就行了吗 不是像袋鼠 而是像青蛙一样我在原田径部部员强韧的脚力牵引下为了不至于被抛下而紧跟上去向前进发增添了两成之后向前进发向着光芒的方向跳跃 前一天晚上看完了续·终物语，今天写这篇文章时，迟迟无法下笔，不知道该怎么写。我突然联想到了四叠半神话大系，两部作品都在结尾点题。刚刚去豆瓣看了一下，现在四叠半在豆瓣电影9分，续终物语8.8分，这足够说明这两部作品的优秀。四叠半重点在于不同的选择，而续重点在于放下曾经的遗憾。就本质上来说，四叠半男主不同的选择，都是为了过上玫瑰色的校园生活，最后的结尾，走出四叠半，面对现实，在这一方面和续不谋而合。 我虽然没有写过一篇关于四叠半的文章，但四叠半在我心中的地位是不可动摇的。目前，我最喜欢的日本动漫里就有四叠半和物语系列，而且他们在很高的位置上。今天我写了这篇关于续·终物语的文章，主要还是因为它和我现在情况非常吻合，对我现在有非常大的启示作用。虽然我刚上大学时并不看动漫，更不用说看四叠半神话大系，但四叠半会一直影响着我，包括即将到来的研究生生活。 很多人问过我，为什么要读研。我只有一个回答：“我太菜了，还是想多学点”。这是实话，可能很多人读研是为了找工作，而我不是，甚至我还想读博。上高中时我就接触学习了计算机和安全相关的知识，当时觉得自己好牛逼，什么都会，周围人全是辣鸡，非常膨胀，因为比别人懂更多的知识，就有点飘飘然了。高考时没考好，考了一个计算机好点的普通一本。不过上了大学，学的知识多了，越发现了自己的不足，其实自己什么都不懂。虽然可能在周围的同学和别人看来，我的确是他们口中的大神，他们的问题我也可以解决。但是我同时见到了在其他地方有更多比我更厉害的人。对比那些少年成才，就算晚了些，也有在大学期间可以日穿各大公司内网，CVE一大堆的大佬，而我和他们相比差距太多了。我想学到更多的东西，也想成为那些真正的大佬，所以选择了继续学习，至于工作，我想如果学到了东西，是不会愁的。 在四叠半中，男主是一个犹豫不决的人，想过上玫瑰色的校园生活，在各个平行世界中不断的做出不同的选择，但最终却什么都没有，并没有过上想象中的生活。而在最后，被困于四叠半的男主，观察到了不同平行世界的自己，以为他们都过这玫瑰色的生活，然而事实却不是这样。最后他冲出四叠半，面向现实，迈出了那一步。就像樋口师傅所说，根本没有玫瑰色的生活。那位算命的老人也在不停的说，良机就在眼前。而男主却总是忽略了眼前的机会，一直裹步不前，总想着换一种选择也许会更好。最后男主认识到了这一切，走出封闭自己的四叠半空间，冲出牢笼，把小熊还给了明石，约她吃猫拉面，找到了自己的黑发少女。 阿良良木历在物语的故事里解决了各种怪异，大多数结果都是比较好的，但是也充满了遗憾。在续终物语中，虽然想继续前进，但由于对过去遗憾的不舍，经历了反转世界。在那个世界里，没有拯救八九寺失败的遗憾，八九寺成功长大、老仓育也没有遗憾，和阿良良木历一起快乐的生活、忍也不是吸血鬼等等。当扇和斧乃木提起，待在这个世界，被这个世界同化，虽然阿良良木历有所犹豫，但都拒绝了。最后和扇的对话，他终于认识到了这一切。并不是他被拉到了镜中，而是他把镜中的世界拉到了现实，表里反转，而这一切的原因就是因为他的犹豫，他对过去遗憾的不舍，无法前进。 续·终物语最后的结尾，被垃圾君和荡漾喂了满口狗粮 只要是与你有关的事情 我就没有留下过遗憾 不过，最后的那部分对话也是点睛升华之笔，也是我想要写这篇文章的原因。我把最后那部分阿良良木历的自述和与战场原的对话全部敲了下来，放到了文章的最后。 就正如没有玫瑰色的校园生活一样，研究生生活也不会是玫瑰色，做出选择就应该一路走下去，不能因为过去的遗憾而后悔迟疑。就正如我现在所面对的一样。充满了遗憾，但也做出了选择，或许可能选择另一条没有遗憾的路可能也不错，但是已经做了选择。犹豫的时候就像续终物语最后阿良良木历面对红绿灯说出的那些话 虽然是很偶然的事情不过从以前开始我在人行横道像这样等红绿灯的时候信号变为绿色的时候我曾经搞不清应当先迈出哪一只脚呢第一步该是右脚呢还是该迈左脚呢或者干脆像迷信一般决定好迈哪只脚好了 一经思考便会迷茫即便头脑中明白必须要前进但双脚却不听使唤就像全身僵住了一般即便知道命运不会因为这种事情而改变即便如此 也会变的迷茫不知方向不是留下心 而是将身体留在了原地 听到阿良良木历说的话，战场原笑了起来，笑的非常厉害，随着一句『这样做不就行了吗』，拉着阿良良木的手一跃而出，阿良良木也为了不被抛下紧跟上去，向着下一个物语起身一跃。 我现在也站在了红绿灯路口，同样面对了要迈出哪只脚的问题。另一方面，我也被四叠半空间所困。走上这条路，做出这个选择，将来要面临的主要只有两个问题，一个是学英语和日语，走学校项目赴日，二就是读博，双线并行，压力更大。而阻拦在这面前的就是我的惰性。我一直知道，我是一个非常懒的人，如果不走出这四叠半的空间，我可能一辈子被其所困。我不想这样，我想做出改变。不仅仅是阿良良木历的续·终物语，也是我的续·终物语。 唤起回忆，放下遗憾，留出余韵和余白。我们向着下一个物语，起身一跃。 我在疑似的『镜中的国度』中经历的哪一件事才是我的遗憾呢又或者说我有许多个遗憾那一切既是她们的遗憾同时也是我自身的遗憾小扇这么说过既是她们的那20% 亦是我的那20%那份被遗弃的丢失的心情或许是想为过去嘲笑火怜穿裙子的事情道歉后悔过去曾经让斧乃木攻击手折正弦而这份后悔或许并没有因为她是人偶而消散没能挽救八九寺将她供奉为神的事情在我还上学的时候没能解决神原左手的问题没能更早的挽救老仓千石的事情更不必说了还有将忍束缚到影子里的事情一年级三班···还有诸多其他事情遗憾的事情堆积如山实在是难以说我怀着轻松舒畅的心情毕业了实际上也不能说是了却了一切遗憾吧不过是回想起来 面对了一切而已大概 这也就足够了吧我无法背负起一切 也不能带着一切前行不过···偶尔回忆起也无妨吧 不过不知道的话 还是很令人在意呢历的遗憾究竟是哪一个呢大家认识出现偏移的阿良良木历形象或许是提示理想的阿良良木历和镜像的阿良良木历我说着玩的 有一件事是确定的只要是与你有关的事情我就没有留下过遗憾因为接下来我们也要一直在一起 还是等成绩发表了之后再说吧要是你落榜了 我们可就四散分离了 虽然是很偶然的事情不过从以前开始我在人行横道像这样等红绿灯的时候信号变为绿色的时候我曾经搞不清应当先迈出哪一只脚呢第一步该是右脚呢还是该迈左脚呢或者干脆像迷信一般决定好迈哪只脚好了 一经思考便会迷茫即便头脑中明白必须要前进但双脚却不听使唤就像全身僵住了一般即便知道命运不会因为这种事情而改变即便如此 也会变的迷茫不知方向不是留下心 而是将身体留在了原地 什么嘛 这种事情而已如果不知道前行时是先迈出右脚还是左脚的话这样做不就行了吗 不是像袋鼠 而是像青蛙一样我在原田径部部员强韧的脚力牵引下为了不至于被抛下而紧跟上去向前进发增添了两成之后向前进发向着光芒的方向跳跃 结束了延续至今的物语唤起回忆 放下遗憾留出余韵和余白 我们向着下一个物语起身一跃]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Delete]]></title>
    <url>%2F2019%2F01%2F06%2Fnew-2019%2F</url>
    <content type="text"><![CDATA[9102年了，看了看以前写的辣鸡文章，想删网站跑路了。想了想，还是没有，删了几篇太蠢的文章…… 想想看自己还是太菜了，越学习越发现自己越菜，连个洞也挖不出来。只求过几个月考研成绩出来可以成功上岸吧~ 成绩出来了，并不理想，顶着压力勉强上岸了。面前只有两条路，出国，读博，或者二合一。总之，硕士期间学习压力可以想象到有多大。 换了电脑以后对blog进行了整体迁移。因为考虑到旧的Next到现在也有很长时间了，就直接用的最新的系统，一次比较彻底的升级，改动很大，不过大多数地方和以前也区别不大。 接下来的一年，只能更努力的学习了。]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF中常见的RSA相关问题总结[转]]]></title>
    <url>%2F2018%2F07%2F21%2FRSA-ATTACK%2F</url>
    <content type="text"><![CDATA[原文:CTF中常见的RSA相关问题总结前言理解基本概念后，代码就可以说明一切，所以本文将每种攻击方式的实现方法都提炼成了一个函数，在理解原理时会有帮助，在需要时也可以直接调用。 基础RSA概要在开始前可以通过 《RSA算法详解》 这篇文章了解关于RSA的基础知识，包括加解密方法，算法原理和可行性证明等。 应用流程 选取两个较大的互不相等的质数p和q，计算n = p * q 。 计算phi = (p-1) * (q-1) 。 选取任意e，使得e满足 1&lt;e&lt;phi 且 gcd(e , phi) == 1 。 计算e关于n的模逆元d， 即d满足(e * d)% n ==1 。 加解密：c = (m ^ e) % n ， m = (c ^ d) % n 。其中m为明文，c为密文，(n,e)为公钥对，d为私钥，要求 0 &lt;= m &lt; n 。 理解模逆运算 如果(a*b)%c==1 ，那么a和b互为对方模c的模逆元/数论倒数，也写作 。 关于最大公约数有一个基本事实：给予两整数a、c，必存在整数x、y使得ax + cy = gcd(a,c) ，基于这个事实，当a,c互素即gcd(a,c)==1 时，有ax+cy=1 ，那么就有(a*x)%c==1 ，所以x就是a 对c的模逆元。因此，a对c存在模逆元b的充要条件是gcd(a,c)==1 。显然对于每一组a,c ，存在一族满足条件的x，在求模逆元时我们取得是最小正整数解x mod n 。 上述的基本事实很容易理解，因为a和c的最大公约数是gcd(a,b)，所以a和c都可表示为gcd(a,b)的整数倍，那么a和b的任意整系数的线性组合ax+by也必定能表示成gcd(a,c)的整数倍，他们当中最小的正整数就应该是gcd(a,c)。实际上最大公约数有一个定义就是：a和b的最大公约数g是a和b的线性和中的最小正整数 。 求模逆元主要基于扩展欧几里得算法，贴一个Python实现： 123456789 def egcd ( a , b ): if (b == 0): return 1, 0, a else: x , y , q = egcd( b , a % b ) # q = GCD(a, b) = GCD(b, a%b) x , y = y, ( x - (a // b) * y ) return x, y, q def mod_inv(a,b): return egcd(a,b)[0]%b #求a模b得逆元 求模逆也可直接利用gmpy2库。如 import gmpy2;print gmpy2.invert(47,30) 可求得47模30的逆为23。模意义下的运算法则 1234567891011121314151617181920(a + b) % n ≡ (a % n + b % n) % n(a - b) % n ≡ (a % n - b % n) % n(a * b) % n ≡ (a % n * b % n) % n(a ^ b) % n ≡ ((a % n) ^ b) % n //幂运算若 a ≡ b(mod n) ,则1.对于任意正整数c,有a^c ≡ b^c(mod n)2.对于任意整数c,有ac ≡ bc(mod n),a+c ≡ b+c(mod n),3.若 c ≡ d(mod n),则a-c ≡ b-d(mod n),a+c ≡ b+d(mod n),ac ≡ bd(mod n)如果ac≡bc (mod m)，且c和m互质，则a≡b (mod m）。[理解：当且仅当c和m互质,c^-1存在,等式左右可同乘模逆。]除法规则：在模n意义下，a/b不再仅仅代表这两个数相除，而是指 a+k1*n 和 b+k2*n这两个组数中任意两个相除，使商为整数因此也就可以理解，除以一个数等价于乘以它的逆a/b ≡ c(mod n) &lt;=&gt; a ≡ c*(b^-1) (mod n)，其中b模n的逆记作b的负一次方。费马小定理:a是整数,p是质数,则a^p==a(mod p),如果a不是p的倍数,还有a^(p-1) ≡ 1(mod p) 推荐文章 模运算总结 和 取模运算涉及的算法 。 欧几里得算法欧几里得算法是求最大公约数的算法, 也就是中学学的 辗转相除法 。记 gcd(a,b) 为a和b的最大公约数，欧几里得算法的基本原理是gcd(a,b)==gcd(b,a%b),(b!=0) 和 gcd(a,0)==a 。 Python实现如下： 123456789# 递归版def gcd(a, b): return a if not b else gcd(b, a % b)# 迭代版def gcd2(a, b): while b: a, b = b, a % b return a 扩展欧几里得算法扩展欧几里得算法基于欧几里得算法，能够求出使得 ax+by=gcd(a,b) 的一组x,y。 这篇文章 解释得很到位，对照下图和以下递归版实现容易理解。 Python实现如下： 12345678910111213141516171819202122232425# 递归版def ext_euclid ( a , b ): # ref:https://zh.wikipedia.org/wiki/扩展欧几里得算法 if (b == 0): return 1, 0, a else: x1 , y1 , q = ext_euclid( b , a % b ) # q = GCD(a, b) = GCD(b, a%b) x , y = y1, ( x1 - (a // b) * y1 ) return x, y, q# 迭代版def egcd(a, b): # ref:https://blog.csdn.net/wyf12138/article/details/60476773 if b == 0: return (1, 0, a) x, y = 0, 1 s1, s2 = 1, 0 r, q = a % b, a / b while r: m, n = x, y x = s1 - x * q y = s2 - y * q s1, s2 = m, n a, b = b, r r, q = a % b, a / b return (x, y, b) 中国剩余定理维基百科 给出了简洁生动的说明: 参考以上说明进行的Python实现: 1234567891011def CRT(mi, ai): # mi,ai分别表示模数和取模后的值,都为列表结构 # Chinese Remainder Theorem # lcm=lambda x , y:x*y/gcd(x,y) # mul=lambda x , y:x*y # assert(reduce(mul,mi)==reduce(lcm,mi)) # 以上可用于保证mi两两互质 assert (isinstance(mi, list) and isinstance(ai, list)) M = reduce(lambda x, y: x * y, mi) ai_ti_Mi = [a * (M / m) * gmpy2.invert(M / m, m) for (m, a) in zip(mi, ai)] return reduce(lambda x, y: x + y, ai_ti_Mi) % M 以上程序将mi当作两两互质处理,实际上有时会遇到其他情况，这时就需要逐一两两合并方程组。我参照下图实现了一个互质与不互质两种情况下都能工作良好的中国剩余定理（解同余方程组）的Python程序。 12345678910111213def GCRT(mi, ai): # mi,ai分别表示模数和取模后的值,都为列表结构 assert (isinstance(mi, list) and isinstance(ai, list)) curm, cura = mi[0], ai[0] for (m, a) in zip(mi[1:], ai[1:]): d = gmpy2.gcd(curm, m) c = a - cura assert (c % d == 0) #不成立则不存在解 K = c / d * gmpy2.invert(curm / d, m / d) cura += curm * K curm = curm * m / d cura %= curm return (cura % curm, curm) #(解,最小公倍数) 图片截自 中国剩余定理（互质与不互质的情况） 。 常见攻击方式实践准备工具 python gmpy2库 Windows：可从https://pypi.org/project/gmpy2/#files 直接下载已编译的安装包。 Linux： sudo apt install python-gmpy2 libnum库： git clone https://github.com/hellman/libnum.git &amp;&amp; cd libnum &amp;&amp; python setup.py install yafu https://sourceforge.net/projects/yafu/ RSATool2v17.exe RSA解密若已知私钥d，则可以直接解密： m=pow(c,d,n) 。 若已知质数p和q，则通过依次计算欧拉函数值phi、私钥d可解密。简易实现如下： 123456789def rsa_decrypt(e, c, p, q): phi = (p - 1) * (q - 1) n = p * q try: d = gmpy2.invert(e, phi) #求e模phi的逆 return pow(c, d, n) except Exception as e: print "e and phi are not coprime!" raise e 在选取加密指数e时要求phi，e互质，也就是gcd(phi,e)==1 ，如果不满足是无法直接解密的。 为什么说这个呢？是因为有时会有乍一看有点奇怪的情况。比如SCTF2018的Crypto - a number problem ，题目是 12x**33=1926041757553905692219721422025224638913707 mod 3436415358139016629092568198745009225773259tell me the smallest answer of x 其中n=3436415358139016629092568198745009225773259 可以直接分解得到p,q，出phi=(p-1)*(q-1) ，然后惊奇地发现gcd(phi,33)==3 。这时如果对加密过程比较熟悉的话，就可以想到实际上公钥e=11 ，明文是m=x^3 ，应该先求出m。然后再爆破x。 123456for i in range(1000000): # 推荐使用gmpy2库运算，用pow开立方不可行 if gmpy2.iroot(m + i * n, 3)[1]: x = gmpy2.iroot(m + i * n, 3)[0] # i==243277,x==9420391510958023 break 查询已知的n的可分解情况在线查询：https://factordb.com/ api接口： 123curl http://factordb.com/api?query=12345response:&#123;"id":"12345","status":"FF","factors":[["3",1],["5",1],["823",1]]&#125; 使用yafu分解N适用情况：p,q相差较大或较小时可快速分解。 使用方法：yafu-x64.exe factor(233) ，yafu-x64.exe help 模不互素 （gcd(N1,N2)!=1）适用情况：存在两个或更多模数 ，且gcd(N1,N2)!=1 。 多个模数n共用质数，则可以很容易利用欧几里得算法求得他们的质因数之一gcd(N1,N2) ，然后这个最大公约数可用于分解模数分别得到对应的p和q，即可进行解密。实现参照本文欧几里得算法 部分和RSA解密 部分。 共模攻击适用情况：明文m、模数n相同，公钥指数e、密文c不同，gcd(e1,e2)==1 对同一明文的多次加密使用相同的模数和不同的公钥指数可能导致共模攻击。简单证明见代码注释。 Python实现： 123456789101112def common_modulus(n, e1, e2, c1, c2): """ ref: https://crypto.stackexchange.com/questions/16283/how-to-use-common-modulus-attack ∵gcd(e1,e2)==1,∴由扩展欧几里得算法，存在e1*s1+e2*s2==1 ∴m==m^1==m^(e1*s1+e2*s2)==((m^e1)^s1)*((m^e2)^s2)==(c1^s1)*(c2^s2) """ assert (libnum.gcd(e1, e2) == 1) _, s1, s2 = gmpy2.gcdext(e1, e2) # 若s1&lt;0，则c1^s1==(c1^-1)^(-s1)，其中c1^-1为c1模n的逆元。 m = pow(c1, s1, n) if s1 &gt; 0 else pow(gmpy2.invert(c1, n), -s1, n) m *= pow(c2, s2, n) if s2 &gt; 0 else pow(gmpy2.invert(c2, n), -s2, n) return m % n 例子：QCTF2018-XMan选拔赛 / Xman-RSA 【共模攻击+模不互素】这道题利用了共模攻击和模不互素。刚开始是一个字符替换，与本文无关。encryption.encrypted文件被做了字符替换，根据语法确定替换表，修复文件得到源文件如下。 题目附件见文末链接。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from gmpy2 import is_primefrom os import urandomimport base64def bytes_to_num(b): return int(b.encode('hex'), 16)def num_to_bytes(n): b = hex(n)[2:-1] b = '0' + b if len(b) % 2 == 1 else b return b.decode('hex')def get_a_prime(l): random_seed = urandom(l) num = bytes_to_num(random_seed) while True: if is_prime(num): break num += 1 return numdef encrypt(s, e, n): p = bytes_to_num(s) p = pow(p, e, n) return num_to_bytes(p).encode('hex')def separate(n): p = n % 4 t = (p * p) % 4 return t == 1f = open('flag.txt', 'r')flag = f.read()msg1 = ""msg2 = ""for i in range(len(flag)): if separate(i): msg2 += flag[i] else: msg1 += flag[i]p1 = get_a_prime(128)p2 = get_a_prime(128)p3 = get_a_prime(128)n1 = p1 * p2n2 = p1 * p3e = 0x1001c1 = encrypt(msg1, e, n1)c2 = encrypt(msg2, e, n2)print(c1)print(c2)e1 = 0x1001e2 = 0x101p4 = get_a_prime(128)p5 = get_a_prime(128)n3 = p4 * p5c1 = num_to_bytes(pow(n1, e1, n3)).encode('hex')c2 = num_to_bytes(pow(n1, e2, n3)).encode('hex')print(c1)print(c2)print(base64.b64encode(num_to_bytes(n2)))print(base64.b64encode(num_to_bytes(n3))) n2，n3已知，利用共模攻击得到n1，由gcd(n1,n2)==p1 分解n1，n2，就可解密得到两部分msg，拼接即可。 解题脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding: utf-8 -*-# by https://findneo.github.io/import base64import libnumimport gmpy2def fix_py(): # decode encryption.encrypted s1 = 'abdefghijklmpqrtuvwxyz' s2 = 'dmenwfoxgpyhirasbktclu' f1 = open('encryption.encrypted') with open('encryption.py', 'w') as f2: for i in f1.readlines(): tmp = '' for j in i: tmp += s2[s1.index(j)] if j in s1 else j f2.write(tmp)# fix_py()def common_modulus(n, e1, e2, c1, c2): assert (libnum.gcd(e1, e2) == 1) _, s1, s2 = gmpy2.gcdext(e1, e2) m = pow(c1, s1, n) if s1 &gt; 0 else pow(gmpy2.invert(c1, n), -s1, n) m *= pow(c2, s2, n) if s2 &gt; 0 else pow(gmpy2.invert(c2, n), -s2, n) m %= n return m[n2, n3] = map(lambda x: int(base64.b64decode(x).encode('hex'), 16), open('n2&amp;n3').readlines())[n1c1, n1c2] = map(lambda x: int(x, 16), open('n1.encrypted').readlines())[msg1c1, msg2c2] = map(lambda x: int(x, 16), open('ciphertext').readlines())# 通过共模攻击得到n1e1 = 0x1001e2 = 0x101n1 = common_modulus(n3, e1, e2, n1c1, n1c2)# n1,n2有一个共有质因数p1# n1 += n3 # 存在n3比n1小的可能，并且确实如此;貌似主办方中途改题，把n1改成小于n3了。p1 = gmpy2.gcd(n1, n2)assert (p1 != 1)p2 = n1 / p1p3 = n2 / p1e = 0x1001d1 = gmpy2.invert(e, (p1 - 1) * (p2 - 1))d2 = gmpy2.invert(e, (p1 - 1) * (p3 - 1))msg1 = pow(msg1c1, d1, n1)msg2 = pow(msg2c2, d2, n2)msg1 = hex(msg1)[2:].decode('hex')msg2 = hex(msg2)[2:].decode('hex')print msg1, msg2# XA&#123;RP0I_0Itrsigi s.y# MNCYT_55_neetnvmrap&#125;# XMAN&#123;CRYPT0_I5_50_Interestingvim rsa.py&#125; 小明文攻击适用情况：e较小，一般为3。 公钥e很小，明文m也不大的话，于是m^e=k*n+m 中的的k值很小甚至为0，爆破k或直接开三次方即可。 Python实现： 123456def small_msg(e, n, c): print time.asctime(), "Let's waiting..." for k in xrange(200000000): if gmpy2.iroot(c + n * k, e)[1] == 1: print time.asctime(), "...done!" return gmpy2.iroot(c + n * k, 3)[0] 例子：Extremely hard RSA题目提供的n是4096位的，e=3。 12345678910111213import gmpy2,binascii,libnum,timen=0xB0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929e=3res=0c=int(open('extremelyhardRSA.rar/flag.enc','rb').read().encode('hex'),16)print time.asctime()for i in xrange(200000000): if gmpy2.iroot(c+n*i,3)[1]==1: res=gmpy2.iroot(c+n*i,3)[0] print i,res print libnum.n2s(res) print time.asctime() break Rabin加密中的N可被分解适用情况：e==2 Rabin加密是RSA的衍生算法，e==2是Rabin加密典型特征，可以百度或阅读 https://en.wikipedia.org/wiki/Rabin_cryptosystem 以了解到详细的说明，这里只关注解密方法。一般先通过其他方法分解得到p，q，然后解密。 Python实现： 1234567891011def rabin_decrypt(c, p, q, e=2): n = p * q mp = pow(c, (p + 1) / 4, p) mq = pow(c, (q + 1) / 4, q) yp = gmpy2.invert(p, q) yq = gmpy2.invert(q, p) r = (yp * p * mq + yq * q * mp) % n rr = n - r s = (yp * p * mq - yq * q * mp) % n ss = n - s return (r, rr, s, ss) 函数返回四个数，这其中只有一个是我们想要的明文，需要通过其他方式验证，当然CTF中显然就是flag字眼了。 解密方法是参照维基百科的，截图如下： 例子：Jarvis OJ hard RSA解题脚本 123456789101112131415161718import gmpy2,libnumn=0xC2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDp=275127860351348928173285174381581152299q=319576316814478949870590164193048041239e=2c=int(open('hardRSA.rar/flag.enc','rb').read().encode('hex'),16)mp=pow(c,(p+1)/4,p)mq=pow(c,(q+1)/4,q)yp=gmpy2.invert(p,q)yq=gmpy2.invert(q,p)r=(yp*p*mq+yq*q*mp)%nrr=n-rs=(yp*p*mq-yq*q*mp)%nss=n-sprint libnum.n2s(r)print libnum.n2s(rr)print libnum.n2s(s)print libnum.n2s(ss) Wiener’s Attack 适用情况：e过大或过小。 工具：https://github.com/pablocelayes/rsa-wiener-attack 在e过大或过小的情况下，可使用算法从e中快速推断出d的值。详细的算法原理可以阅读：低解密指数攻击 。 123456789101112131415161718from Crypto.PublicKey import RSAimport ContinuedFractions, Arithmeticdef wiener_hack(e, n): # firstly git clone https://github.com/pablocelayes/rsa-wiener-attack.git ! frac = ContinuedFractions.rational_to_contfrac(e, n) convergents = ContinuedFractions.convergents_from_contfrac(frac) for (k, d) in convergents: if k != 0 and (e * d - 1) % k == 0: phi = (e * d - 1) // k s = n - phi + 1 discr = s * s - 4 * n if (discr &gt;= 0): t = Arithmetic.is_perfect_square(discr) if t != -1 and (s + t) % 2 == 0: print("Hacked!") return d return False 例子：2018强网杯nextrsa-Level21234n = 0x92411fa0c93c1b27f89e436d8c4698bcf554938396803a5b62bd10c9bfcbf85a483bd87bb2d6a8dc00c32d8a7caf30d8899d90cb8f5838cae95f7ff5358847db1244006c140edfcc36adbdcaa16cd27432b4d50d2348b5c15c209364d7914ef50425e4c3da07612cc34e9b93b98d394b43f3eb0a5a806c70f06697b6189606eb9707104a7b6ff059011bac957e2aae9ec406a4ff8f8062400d2312a207a9e018f4b4e961c943dfc410a26828d2e88b24e4100162228a5bbf0824cf2f1c8e7b915efa385efeb505a9746e5d19967766618007ddf0d99525e9a41997217484d64c6a879d762098b9807bee46a219be76941b9ff31465463981e230eecec69691d1Le = 0x6f6b385dd0f06043c20a7d8e5920802265e1baab9d692e7c20b69391cc5635dbcaae59726ec5882f168b3a292bd52c976533d3ad498b7f561c3dc01a76597e47cfe60614f247551b3dbe200e2196eaa001a1d183886eeacddfe82d80b38aea24de1a337177683ed802942827ce4d28e20efef92f38f1b1a18c66f9b45f5148cceabfd736de8ac4a49e63a8d35a83b664f9f3b00f822b6f11ff13257ee6e0c00ca5c98e661ea594a9e66f2bd56b33d9a13f5c997e67a37fcf9a0c7f04d119fe1ba261127357e64a4b069aefed3049c1c1fe4f964fd078b88bedd064abea385cfebd65e563f93c12d34eb6426e8aa321033cfd8fe8855b9e74d07fe4f9d70de46fLd = wiener_hack(e, n)print d #42043 私钥文件修复适用情况：提供破损的私钥文件。 例子：Jarvis OJ-God Like RSA参考 https://www.40huo.cn/blog/rsa-private-key-recovery-and-oaep.html 修复存储私钥的文件，得到p和q。 1234567891011121314151617import gmpy2,binascii,libnum,timefrom Crypto.PublicKey import RSAwith open('godlikeRSA.rar/pubkey.pem', 'r') as f: key = RSA.importKey(f) n = key.n e = key.ep = 30061432003658510087798871614869318011389940352798147030129806359975911392091235344042288409629143229311060231549478211871643725394470760528211801310601767727834886942210718412087541234398453046895030858579989874035849439867334906873642352112428914855967993998732685221108379784833027771293275558876952608462050146340591449046825135890871650866799299533696175818103240024841274114925018619060818213433528894936128306780366785977567327073724428211445259983614467640785163297734447975723664659822673456683284394386723716344090232882990461174301609971805075768328757325956784604364401827152431260896927633163074694121679q = 26136662545551829820746942051638228325025130519175536694008242208616774469870765684858288042819063837180243501117310278632509413217676559484513481677689042623348188876598901642459170232360966754692434316796014314498263800234390539118817050074978421973817764644287745302885861277447227180288605200894138168586207384484170481511828680117688324729381172912436910052489279406590356734739774635376711681212908417321705094537960645308009611045658947359297373154395500467689532455017647450616447445444254910371922944620114234547655209970657063715028350418518417105772707885648587233103869340985670430269862943630137067052883print n==p*qphi=(p-1)*(q-1)d=gmpy2.invert(e,phi)print e*d%phic=int(open('godlikeRSA.rar/flag.enc','rb').read().encode('hex'),16)m=pow(c,d,n)print m# 1370223550024951160390505387130177939237950112048472397389773634788136940247048803373180904499220116137720016277614401463947529601059601275191225565163007356175594695217230371190488219356030961008234353281422568670237109241798409859772276203338663213736672988507101836099731545753186306605979236795416523018072994981230167509019379957053839561135207769133885837247551721998502691458955042383536845772871317832519566606644011038158531192089650858814552702073939336587081668849526410118259284356539710136294431275218448114094635426857980426460905608258535404240097392254948848433684475139365021846569436926295331904560877283857331146381104141185386272078892946248648795223866902960499271054375730866146508724739787771837579817109380817612386428775429383894697178101165350212843220568133053034913426083965937819287414427916848075303046293039426388342757953620799736182799948741710617974079729792088434776370340095313622264898772452440870247810948774919910578850614282925852564445288646487485017449052934955175051072066751519784123645584671119185023928739438748519535869994754998423784897445884244844154563303115861175492133906368196005147361767160830004522010287149025190543608485818909441439294996482797249312140402141744752129890112# 明文是这个，flag是啥不知道 LSB Oracle Attack适用情况：可以选择密文并泄露最低位。 在一次RSA加密中，明文为m，模数为n，加密指数为e，密文为c。我们可以构造出c&#39;=((2^e)*c)%n=((2^e)*(m^e))%n=((2*m)^e)%n ， 因为m的两倍可能大于n，所以经过解密得到的明文是 m&#39;=(2*m)%n 。我们还能够知道 m&#39; 的最低位lsb 是1还是0。 因为n是奇数，而2*m 是偶数，所以如果lsb 是0，说明(2*m)%n 是偶数，没有超过n，即m&lt;n/2.0 ，反之则m&gt;n/2.0 。举个例子就能明白2%3=2 是偶数，而4%3=1 是奇数。以此类推，构造密文c&quot;=(4^e)*c)%n 使其解密后为m&quot;=(4*m)%n ，判断m&quot; 的奇偶性可以知道m 和 n/4 的大小关系。所以我们就有了一个二分算法，可以在对数时间内将m的范围逼近到一个足够狭窄的空间。 更多信息可参考：RSA Least-Significant-Bit Oracle Attack 和 RSA least significant bit oracle attack 。 Python实现： 123456789101112131415161718import decimaldef oracle(): return lsb == 'odd'def partial(c, e, n): k = n.bit_length() decimal.getcontext().prec = k # for 'precise enough' floats lo = decimal.Decimal(0) hi = decimal.Decimal(n) for i in range(k): if not oracle(c): hi = (lo + hi) / 2 else: lo = (lo + hi) / 2 c = (c * pow(2, e, n)) % n # print i, int(hi - lo) return int(hi) 例子：QCTF2018-XMan选拔赛/Baby RSA题目如下 1234567891011e = 0x10001n = 0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716dbc = 0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0λ nc 47.96.239.28 23333----------------------------- baby rsa -----------------------------Come and Decode your dataIf you give me ciphertext, I can tell you whether decoded data is even or oddYou can input ciphertext(hexdecimal) now1odd 解题脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# -*- coding: utf-8 -*-# by https://findneo.github.io/# ref:# https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack# https://ctf.rip/sharif-ctf-2016-lsb-oracle-crypto-challenge/# https://introspelliam.github.io/2018/03/27/crypto/RSA-Least-Significant-Bit-Oracle-Attack/import libnum, gmpy2, socket, time, decimaldef oracle(c1): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) hostname = '47.96.239.28' port = 23333 s.connect((hostname, port)) s.recv(1024) s.send(hex(c1)[2:].strip("lL") + '\n') res = s.recv(1024).strip() s.close() if res == 'even': return 0 if res == 'odd': return 1 else: assert (0)def partial(c, n): global c_of_2 k = n.bit_length() decimal.getcontext().prec = k # allows for 'precise enough' floats lower = decimal.Decimal(0) upper = decimal.Decimal(n) for i in range(k): possible_plaintext = (lower + upper) / 2 # lower==0 when i&lt;1809 flag = oracle(c) if not flag: upper = possible_plaintext # plaintext is in the lower half else: lower = possible_plaintext # plaintext is in the upper half c = (c * c_of_2) % n # multiply y by the encryption of 2 again print i, flag, int(upper - lower) # time.sleep(0.2) # By now, our plaintext is revealed! return int(upper)def main(): print "[*] Conducting Oracle attack..." return partial((c * c_of_2) % n, n)if __name__ == '__main__': e = 0x10001 n = 0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716db c = 0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0 c_of_2 = pow(2, e, n) m = main() # m = 560856645743734814774953158390773525781916094468093308691660509501812349 print libnum.n2s(m) # QCTF&#123;RSA_parity_oracle_is_fun&#125; 选择密文攻击适用情况：可以构造任意密文并获得对应明文。 这个好理解，在一个RSA加密过程中，明文为m，密文为c，模数为n，加密指数为e，选取x以满足gcd(x,n)==1 从而使x模n的逆存在，构造密文 c&#39;=c*(x^e) 使解密后明文为 m&#39;=(m*x)%n ，则m=m&#39;*x^-1(mod n) 。可参看模意义下的运算法则部分 。 广播攻击适用情况：模数n、密文c不同，明文m、加密指数e相同。一般会是e=k，然后给k组数据 使用不同的模数n，相同的公钥指数e加密相同的信息。就会得到多个(m^e) ==ci (mod ni)，将(m^e)视为一个整体M，这就是典型的中国剩余定理适用情况。按照本文的中国剩余定理小节容易求得m^e的值，当e较小时直接开e方即可，可使用gmpy2.iroot(M,e) 方法。 Python实现：参见本文 中国剩余定理小节。 例子：2018强网杯nextrsa-Level9123456789m = random.randint(0x100000000000, 0xffffffffffff)e = 3n1 = 0x43d819a4caf16806e1c540fd7c0e51a96a6dfdbe68735a5fd99a468825e5ee55c4087106f7d1f91e10d50df1f2082f0f32bb82f398134b0b8758353bdabc5ba2817f4e6e0786e176686b2e75a7c47d073f346d6adb2684a9d28b658dddc75b3c5d10a22a3e85c6c12549d0ce7577e79a068405d3904f3f6b9cc408c4cd8595bf67fe672474e0b94dc99072caaa4f866fc6c3feddc74f10d6a0fb31864f52adef71649684f1a72c910ec5ca7909cc10aef85d43a57ec91f096a2d4794299e967fcd5add6e9cfb5baf7751387e24b93dbc1f37315ce573dc063ecddd4ae6fb9127307cfc80a037e7ff5c40a5f7590c8b2f5bd06dd392fbc51e5d059cffbcb85555Ln2 = 0x60d175fdb0a96eca160fb0cbf8bad1a14dd680d353a7b3bc77e620437da70fd9153f7609efde652b825c4ae7f25decf14a3c8240ea8c5892003f1430cc88b0ded9dae12ebffc6b23632ac530ac4ae23fbffb7cfe431ff3d802f5a54ab76257a86aeec1cf47d482fec970fc27c5b376fbf2cf993270bba9b78174395de3346d4e221d1eafdb8eecc8edb953d1ccaa5fc250aed83b3a458f9e9d947c4b01a6e72ce4fee37e77faaf5597d780ad5f0a7623edb08ce76264f72c3ff17afc932f5812b10692bcc941a18b6f3904ca31d038baf3fc1968d1cc0588a656d0c53cd5c89cedba8a5230956af2170554d27f524c2027adce84fd4d0e018dc88ca4d5d26867Ln3 = 0x280f992dd63fcabdcb739f52c5ed1887e720cbfe73153adf5405819396b28cb54423d196600cce76c8554cd963281fc4b153e3b257e96d091e5d99567dd1fa9ace52511ace4da407f5269e71b1b13822316d751e788dc935d63916075530d7fb89cbec9b02c01aef19c39b4ecaa1f7fe2faf990aa938eb89730eda30558e669da5459ed96f1463a983443187359c07fba8e97024452087b410c9ac1e39ed1c74f380fd29ebdd28618d60c36e6973fc87c066cae05e9e270b5ac25ea5ca0bac5948de0263d8cc89d91c4b574202e71811d0ddf1ed23c1bc35f3a042aac6a0bdf32d37dede3536f70c257aafb4cfbe3370cd7b4187c023c35671de3888a1ed1303Lc1 = pow(m, e, n1)c2 = pow(m, e, n2)c3 = pow(m, e, n3)print m == gmpy2.iroot(CRT([n1, n2, n3], [c1, c2, c3]), e)[0] 其他例题【Jarvis OJ Medium RSA】解析公钥文件使用命令从PEM文件（Privacy-Enhanced Mail 是用于存储和发送密钥、证书等数据的文件格式）中解析公钥对(n,e)，n可在线查询 (http://factordb.com/) 到质因子，分解n得到p和q，便能够计算欧拉函数值及解密指数，从而解密。 123456789101112131415C:\Users\neo\Downloads\mediumRSA.rarλ openssl rsa -pubin -text -modulus -in pubkey.pemWARNING: can't open config file: /usr/local/ssl/openssl.cnfPublic-Key: (256 bit)Modulus: 00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:ddExponent: 65537 (0x10001)Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDwriting RSA key-----BEGIN PUBLIC KEY-----MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDryigb/+l/vjDdAgMBAAE=-----END PUBLIC KEY----- carck.py 1234567891011import gmpy2,binasciin=87924348264132406875276140514499937145050893665602592992418171647042491658461e=0x10001# via http://factordb.com/p=275127860351348928173285174381581152299q=319576316814478949870590164193048041239d=gmpy2.invert(e,(p-1)*(q-1))c=int(open('flag.enc','rb').read().encode('hex'),16)m=hex(pow(c,d,n))[2:]print binascii.unhexlify(m.zfill(len(m)+8-len(m)%8)) 后话RSA可谓现代密码学的中流砥柱，关于它的可行攻击方法研究还有很多，诸如Timing Attack ，Padding oracle attack，Side-channel analysis attacks等类型的攻击，本文仅介绍了一些通俗易懂的方法，读者还可以阅读 CTF wiki中的非对称加密部分 ，以及以 RSA (cryptosystem) 为目录结合谷歌进行进一步学习。 本文的例题附件、代码段、工具和后续更新都会放在 RSA-ATTACK ，欢迎 star &amp; watch 。 参考链接Practical Padding Oracle Attacks on RSA CTF wiki中的非对称加密部分]]></content>
      <tags>
        <tag>技术</tag>
        <tag>安全</tag>
        <tag>密码学</tag>
        <tag>学习笔记</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[培根密码栅栏密码]]></title>
    <url>%2F2018%2F02%2F15%2Fbacon-fence%2F</url>
    <content type="text"><![CDATA[接上一篇的AES，在写Crypto类库时也写了培根密码和栅栏密码，这里也写一下这两中加密算法。 培根密码培根密码，又名倍康尼密码（英语：Bacon’s cipher）是由法兰西斯·培根发明的一种隐写术。[维基百科] 原理加密时，明文中的每个字母都会转换成一组五个英文字母。其转换依靠下表：123456a AAAAA g AABBA n ABBAA t BAABAb AAAAB h AABBB o ABBAB u-v BAABBc AAABA i-j ABAAA p ABBBA w BABAAd AAABB k ABAAB q ABBBB x BABABe AABAA l ABABA r BAAAA y BABBAf AABAB m ABABB s BAAAB z BABBB 这只是一款最常用的加密表，有另外一款将每种字母配以不同的字母组予以转换，即I与J、U与V皆有不同编号。 加密者需使用两种不同字体，分别代表A和B。准备好一篇包含相同AB字数的假信息后，按照密文格式化假信息，即依密文中每个字母是A还是B分别套用两种字体。 解密时，将上述方法倒转。所有字体一转回A，字体二转回B，以后再按上表拼回字母。 法兰西斯·培根另外准备了一种方法，其将大小写分别看作A与B，可用于无法使用不同字体的场合（例如只能处理纯文本时）。但这样比起字体不同更容易被看出来，而且和语言对大小写的要求也不太兼容。 培根密码本质上是将二进制信息通过样式的区别，加在了正常书写之上。培根密码所包含的信息可以和用于承载其的文章完全无关。 代码实现代码这里只写加密算法了，解密也类似于摩斯密码，具体可以去Github看我的Crypto类库，使用时直接引用就行了。12345678910111213141516171819202122232425static private string[] baconArray = &#123; "AAAAA", "AAAAB", "AAABA", "AAABB", "AABAA", "AABAB", "AABBA","AABBB","ABAAA","ABAAA","ABAAB","ABABA","ABABB","ABBAA","ABBAB","ABBBA","ABBBB", "BAAAA","BAAAB","BAABA","BAABB","BAABB","BABAA","BABAB","BABBA","BABBB"&#125;;/// &lt;summary&gt;/// 培根加密/// &lt;/summary&gt;/// &lt;param name="str"&gt;明文&lt;/param&gt;/// &lt;returns&gt;密文&lt;/returns&gt;static public string baconEncrypt(string str)&#123; str = str.ToUpper(); string result = ""; for (int i = 0; i &lt; str.Length; i++) &#123; char ch = str[i]; if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') &#123; result += baconArray[ch - 'A']; &#125; else throw new Exception("输入有误"); &#125; return result;&#125; 结果1234请输入要加解密的字符串：willv培根加密结果为：BABAAABAAAABABAABABABAABB请输入要加解密的字符串：BABAAABAAAABABAABABABAABB培根加密结果为：WI(J)LLU(V) 栅栏密码栅栏密码，就是把要加密的明文分成N个一组，然后把每组的第1个字连起来，形成一段无规律的话。 不过栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多。（一般不超过30个，也就是一、两句话） 加解密实例[百度百科]一般比较常见的是2栏的栅栏密码。比如明文：THERE IS A CIPHER去掉空格后变为：THEREISACIPHER两个一组，得到：TH ER EI SA CI PH ER先取出第一个字母：TEESCPE再取出第二个字母：HRIAIHR连在一起就是：TEESCPEHRIAIHR还原为所需密码。而解密的时候，我们先把密文从中间分开，变为两行：T E E S C P EH R I A I H R再按上下上下的顺序组合起来：THEREISACIPHER分出空格，就可以得到原文了：THERE IS A CIPHER不是所有密码都分为两栏，比如：明文：THERE IS A CIPHER七个一组：THEREIS ACIPHER抽取字母：TA HC EI RP EH IE SR组合得到密码：TAHCEIRPEHIESR那么这时候就无法再按照2栏的方法来解了…1分析解码这样，我们可以通过分析密码的字母数来解出密码…比如：TAHCEIRPEHIESR一共有14个字母，可能是2栏或者7栏…尝试2栏…失败尝试7栏…成功 代码实现栅栏密码的代码实现也比较简单。我还另外写了一个获取栅栏数的函数。1234567891011121314str = str.Replace(" ", "");int length = str.Length;int[] result;Stack&lt;int&gt; s = new Stack&lt;int&gt; &#123; &#125;;//分解因数for (int i = 2; i &lt; System.Math.Sqrt(length); i++) //博扬大佬说到开根号就行了&#123; if (length%i==0) &#123; s.Push(i); &#125;&#125;result = s.Reverse().ToArray();return result; 以栅栏密码加密为例（我在类库Crypto中加入了移除空格，如果需要空格的话需要重编译一下删除替换代码）123456789101112131415161718192021222324252627282930313233343536373839/// &lt;summary&gt;/// 栅栏密码加密/// &lt;/summary&gt;/// &lt;param name="str"&gt;明文&lt;/param&gt;/// &lt;param name="num"&gt;栅栏数&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;static public string fenceEncrypt(string str,int num)&#123; /* * 明文：THERE IS A CIPHER * 七个一组：THEREIS ACIPHER * 抽取字母：TA HC EI RP EH IE SR * 组合得到密码：TAHCEIRPEHIESR */ str = str.Replace(" ", ""); if (str.Length%num!=0) &#123; throw new Exception("栅栏数错误"); &#125; int cp = str.Length / num; //可分的组数 string[] temp = new string[cp]; //保存分组 for (int i = 0; i &lt; cp; i++) //为分组复制 &#123; for (int j = 0; j &lt; num; j++) &#123; temp[i] += str[i * num + j]; &#125; &#125; string result = ""; //抽取字母 for (int i = 0; i &lt; num; i++) &#123; for (int j = 0; j &lt; cp; j++) &#123; result += temp[j][i]; &#125; &#125; return result;&#125; 栅栏密码的解密很简单，比如长度35的明文栅栏数5加密后，对密文进行以栅栏数为7再加密一次就可以解密了，数学证明很简单在这里就不写了。 结果以实例中的字符串THERE IS A CIPHER为例1234请输入要加解密的字符串：THERE IS A CIPHER栅栏加密结果为：TEESCPEHRIAIHR请输入要加解密的字符串：TEESCPEHRIAIHR栅栏解密结果为：THEREISACIPHER]]></content>
      <tags>
        <tag>技术</tag>
        <tag>安全</tag>
        <tag>密码学</tag>
        <tag>学习笔记</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AES学习]]></title>
    <url>%2F2018%2F02%2F13%2Faes-study%2F</url>
    <content type="text"><![CDATA[最近在写一个常见加密编码的类库Crypto，其中涉及到很多加密及编码方式。写到了AES这里，遇到点麻烦，也是学习了一下AES加密。 高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。该算法为比利时密码学家Joan Daemen和Vincent Rijmen所设计，结合两位作者的名字，以Rijndael为名投稿高级加密标准的甄选流程。（Rijndael的发音近于”Rhine doll”）（来自维基百科） AES高级加密标准 - 维基百科严格地说，AES和Rijndael加密法并不完全一样（虽然在实际应用中两者可以互换），因为Rijndael加密法可以支持更大范围的区块和密钥长度：AES的区块长度固定为128比特，密钥长度则可以是128，192或256比特；而Rijndael使用的密钥和区块长度均可以是128，192或256比特。加密过程中使用的密钥是由Rijndael密钥生成方案产生。 大多数AES计算是在一个特别的有限域完成的。 AES加密过程是在一个4×4的字节矩阵上运作，这个矩阵又称为“体（state）”，其初值就是一个明文区块（矩阵中一个元素大小就是明文区块中的一个Byte）。（Rijndael加密法因支持更大的区块，其矩阵行数可视情况增加）加密时，各轮AES加密循环（除最后一轮外）均包含4个步骤： AddRoundKey—矩阵中的每一个字节都与该次回合密钥（round key）做XOR运算；每个子密钥由密钥生成方案产生。 SubBytes—通过一个非线性的替换函数，用查找表的方式把每个字节替换成对应的字节。 ShiftRows—将矩阵中的每个横列进行循环式移位。 MixColumns—为了充分混合矩阵中各个直行的操作。这个步骤使用线性转换来混合每内联的四个字节。最后一个加密循环中省略MixColumns步骤，而以另一个AddRoundKey取代。 分组密码工作模式分组密码工作模式 - 维基百科密码学中，分组（block）密码的工作模式（mode of operation）允许使用同一个分组密码密钥对多于一块的数据进行加密，并保证其安全性。分组密码自身只能加密长度等于密码分组长度的单块数据，若要加密变长数据，则数据必须先被划分为一些单独的密码块。通常而言，最后一块数据也需要使用合适填充方式将数据扩展到匹配密码块大小的长度。一种工作模式描述了加密每一数据块的过程，并常常使用基于一个通常称为初始化向量的附加输入值以进行随机化，以保证安全。 工作模式主要用来进行加密和认证。对加密模式的研究曾经包含数据的完整性保护，即在某些数据被修改后的情况下密码的误差传播特性。后来的研究则将完整性保护作为另一个完全不同的，与加密无关的密码学目标。部分现代的工作模式用有效的方法将加密和认证结合起来，称为认证加密模式。 虽然工作模式通常应用于对称加密，它亦可以应用于公钥加密，例如在原理上对RSA进行处理，但在实用中，公钥密码学通常不用于加密较长的信息，而是使用结合对称加密和公钥加密的混合加密方案。 初始化向量（IV）初始化向量 - 维基百科初始化向量（IV，Initialization Vector）是许多任务作模式中用于将加密随机化的一个位块，由此即使同样的明文被多次加密也会产生不同的密文，避免了较慢的重新产生密钥的过程。 初始化向量与密钥相比有不同的安全性需求，因此IV通常无须保密，然而在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个IV。对于CBC和CFB，重用IV会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。对于OFB和CTR而言，重用IV会导致完全失去安全性。另外，在CBC模式中，IV在加密时必须是无法预测的；特别的，在许多实现中使用的产生IV的方法，例如SSL2.0使用的，即采用上一个消息的最后一块密文作为下一个消息的IV，是不安全的。 填充填充 (密码学) - 维基百科块密码只能对确定长度的数据块进行处理，而消息的长度通常是可变的。因此部分模式（即ECB和CBC）需要最后一块在加密前进行填充。有数种填充方法，其中最简单的一种是在明文的最后填充空字符以使其长度为块长度的整数倍，但必须保证可以恢复明文的原始长度；例如，若明文是C语言风格的字符串，则只有串尾会有空字符。稍微复杂一点的方法则是原始的DES使用的方法，即在数据后添加一个1位，再添加足够的0位直到满足块长度的要求；若消息长度刚好匹配块长度，则添加一个填充块。最复杂的则是针对CBC的方法，例如密文窃取，残块终结等，不会产生额外的密文，但会增加一些复杂度。布鲁斯·施奈尔和尼尔斯·弗格森提出了两种简单的可能性：添加一个值为128的字节（十六进制的80），再以0字节填满最后一个块；或向最后一个块填充n个值均为n的字节。 CFB，OFB和CTR模式不需要对长度不为密码块大小整数倍的消息进行特别的处理。因为这些模式是通过对块密码的输出与明文进行异或工作的。最后一个明文块（可能是不完整的）与密钥流块的前几个字节异或后，产生了与该明文块大小相同的密文块。流密码的这个特性使得它们可以应用在需要密文和明文数据长度严格相等的场合，也可以应用在以流形式传输数据而不便于进行填充的场合。 常用模式电子密码本（ECB）最简单的加密模式即为电子密码本（Electronic codebook，ECB）模式。需要加密的消息按照块密码的块大小被分为数个块，并对每个块进行独立加密。 本方法的缺点在于同样的明文块会被加密成相同的密文块；因此，它不能很好的隐藏数据模式。在某些场合，这种方法不能提供严格的数据保密性，因此并不推荐用于密码协议中。ECB模式也会导致使用它的协议不能提供数据完整性保护，易受到重放攻击的影响，因此每个块是以完全相同的方式解密的。例如，“梦幻之星在线：蓝色脉冲”在线电子游戏使用ECB模式的Blowfish密码。在密钥交换系统被破解而产生更简单的破解方式前，作弊者重复通过发送加密的“杀死怪物”消息包以非法的快速增加经验值。 密码块链接（CBC）1976年，IBM发明了密码分组链接（CBC，Cipher-block chaining）模式。在CBC模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。 若第一个块的下标为1，则CBC模式的加密过程为而其解密过程则为CBC是最为常用的工作模式。它的主要缺点在于加密过程是串行的，无法被并行化，而且消息必须被填充到块大小的整数倍。解决后一个问题的一种方法是利用密文窃取。 注意在加密时，明文中的微小改变会导致其后的全部密文块发生改变，而在解密时，从两个邻接的密文块中即可得到一个明文块。因此，解密过程可以被并行化，而解密时，密文中一位的改变只会导致其对应的明文块完全改变和下一个明文块中对应位发生改变，不会影响到其它明文的内容。 填充密码块链接（PCBC）填充密码块链接（PCBC，Propagating cipher-block chaining）或称为明文密码块链接（Plaintext cipher-block chaining），是一种可以使密文中的微小更改在解密时导致明文大部分错误的模式，并在加密的时候也具有同样的特性。加密和解密算法如下：PCBC主要用于Kerberos v4和WASTE中，而在其它场合的应用较少。对于使用PCBC加密的消息，互换两个邻接的密文块不会对后续块的解密造成影响。正因为这个特性，Kerberos v5没有使用PCBC。 密文反馈（CFB）密文反馈（CFB，Cipher feedback）模式类似于CBC，可以将块密码变为自同步的流密码；工作过程亦非常相似，CFB的解密过程几乎就是颠倒的CBC的加密过程： 上述公式是描述的是最简单的CFB，在这种模式下，它的自同步特性仅仅与CBC相同，即若密文的一整块发生错误，CBC和CFB都仍能解密大部分数据，而仅有一位数据错误。若需要在仅有了一位或一字节错误的情况下也让模式具有自同步性，必须每次只加密一位或一字节。可以将移位寄存器作为块密码的输入，以利用CFB的自同步性。 与CBC相似，明文的改变会影响接下来所有的密文，因此加密过程不能并行化；而同样的，与CBC类似，解密过程是可以并行化的。在解密时，密文中一位数据的改变仅会影响两个明文块：对应明文块中的一位数据与下一块中全部的数据，而之后的数据将恢复正常。 CFB拥有一些CBC所不具备的特性，这些特性与OFB和CTR的流模式相似：只需要使用块密码进行加密操作，且消息无需进行填充（虽然密文窃取也允许数据不进行填充）。 输出反馈（OFB）输出反馈模式（Output feedback, OFB）可以将块密码变成同步的流密码。它产生密钥流的块，然后将其与明文块进行异或，得到密文。与其它流密码一样，密文中一个位的翻转会使明文中同样位置的位也产生翻转。这种特性使得许多错误校正码，例如奇偶校验位，即使在加密前计算，而在加密后进行校验也可以得出正确结果。 由于XOR操作的对称性，加密和解密操作是完全相同的： 每个使用OFB的输出块与其前面所有的输出块相关，因此不能并行化处理。然而，由于明文和密文只在最终的异或过程中使用，因此可以事先对IV进行加密，最后并行的将明文或密文进行并行的异或处理。 可以利用输入全0的CBC模式产生OFB模式的密钥流。这种方法十分实用，因为可以利用快速的CBC硬件实现来加速OFB模式的加密过程。 计数器模式（CTR）注意：CTR模式（Counter mode，CM）也被称为ICM模式（Integer Counter Mode，整数计数模式）和SIC模式（Segmented Integer Counter）。与OFB相似，CTR将块密码变为流密码。它通过递增一个加密计数器以产生连续的密钥流，其中，计数器可以是任意保证长时间不产生重复输出的函数，但使用一个普通的计数器是最简单和最常见的做法。使用简单的、定义好的输入函数是有争议的：批评者认为它“有意的将密码系统暴露在已知的、系统的输入会造成不必要的风险”。目前，CTR已经被广泛的使用了，由输入函数造成的问题被认为是使用的块密码的缺陷，而非CTR模式本身的弱点。无论如何，有一些特别的攻击方法，例如基于使用简单计数器作为输入的硬件差错攻击。 CTR模式的特征类似于OFB，但它允许在解密时进行随机存取。由于加密和解密过程均可以进行并行处理，CTR适合运用于多处理器的硬件上。 注意图中的“nonce”与其它图中的IV（初始化向量）相同。IV、随机数和计数器均可以通过连接，相加或异或使得相同明文产生不同的密文。 代码实现代码为C#，为128位AES加解密（CBC模式PKCS7填充），需要引入命名空间System.Security.Cryptography1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/// &lt;summary&gt;/// AES加密（CBC模式PKCS7填充）/// &lt;/summary&gt;/// &lt;param name="text"&gt;加密字符&lt;/param&gt;/// &lt;param name="password"&gt;加密的密码&lt;/param&gt;/// &lt;param name="iv"&gt;密钥向量&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string AESEncrypt(string text, string password, string iv)&#123; int size = 128; int bytesNum = size / 8; RijndaelManaged rijndaelCipher = new RijndaelManaged(); rijndaelCipher.Mode = CipherMode.CBC; rijndaelCipher.Padding = PaddingMode.PKCS7; rijndaelCipher.KeySize = size; rijndaelCipher.BlockSize = 128; byte[] pwdBytes = System.Text.Encoding.UTF8.GetBytes(password); byte[] keyBytes = new byte[bytesNum]; int len = pwdBytes.Length; if (len &gt; keyBytes.Length) len = keyBytes.Length; System.Array.Copy(pwdBytes, keyBytes, len); rijndaelCipher.Key = keyBytes; byte[] ivBytes = System.Text.Encoding.UTF8.GetBytes(iv); rijndaelCipher.IV = ivBytes; ICryptoTransform transform = rijndaelCipher.CreateEncryptor(); byte[] plainText = Encoding.UTF8.GetBytes(text); byte[] cipherBytes = transform.TransformFinalBlock(plainText, 0, plainText.Length); return Convert.ToBase64String(cipherBytes);&#125;/// &lt;summary&gt;/// 随机生成密钥向量/// &lt;/summary&gt;/// &lt;param name="n"&gt;位数&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string GetIv(int n)&#123; char[] arrChar = new char[]&#123; 'a','b','d','c','e','f','g','h','i','j','k','l','m','n','p','r','q','s','t','u','v','w','z','y','x', '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','Q','P','R','T','S','V','U','W','X','Y','Z' &#125;; StringBuilder num = new StringBuilder(); Random rnd = new Random(DateTime.Now.Millisecond); for (int i = 0; i &lt; n; i++) &#123; num.Append(arrChar[rnd.Next(0, arrChar.Length)].ToString()); &#125; return num.ToString();&#125;/// &lt;summary&gt;/// AES解密（CBC模式PKCS7填充）/// &lt;/summary&gt;/// &lt;param name="text"&gt;密文&lt;/param&gt;/// &lt;param name="password"&gt;密码&lt;/param&gt;/// &lt;param name="iv"&gt;密钥向量&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string AESDecrypt(string text, string password, string iv)&#123; int size = 128; int bytesNum = size / 8; RijndaelManaged rijndaelCipher = new RijndaelManaged(); rijndaelCipher.Mode = CipherMode.CBC; //CBC加密模式 rijndaelCipher.Padding = PaddingMode.PKCS7; //PKCS7填充 rijndaelCipher.KeySize = size; rijndaelCipher.BlockSize = 128; byte[] encryptedData = Convert.FromBase64String(text); byte[] pwdBytes = System.Text.Encoding.UTF8.GetBytes(password); byte[] keyBytes = new byte[bytesNum]; int len = pwdBytes.Length; if (len &gt; keyBytes.Length) len = keyBytes.Length; System.Array.Copy(pwdBytes, keyBytes, len); rijndaelCipher.Key = keyBytes; byte[] ivBytes = System.Text.Encoding.UTF8.GetBytes(iv); rijndaelCipher.IV = ivBytes; ICryptoTransform transform = rijndaelCipher.CreateDecryptor(); byte[] plainText = transform.TransformFinalBlock(encryptedData, 0, encryptedData.Length); return Encoding.UTF8.GetString(plainText);&#125; 测试运行：123456789请输入要加解密的字符串：时光随机生成的iv为:8EAD20lxJlHdRcwr请输入密码:willv128位AES(CBC)加密:elbuc+G8ycb6ydwVrRLyhQ==请输入要加解密的字符串：elbuc+G8ycb6ydwVrRLyhQ==请输入iv:8EAD20lxJlHdRcwr请输入密码:willv128位AES(CBC)解密:时光]]></content>
      <tags>
        <tag>技术</tag>
        <tag>安全</tag>
        <tag>密码学</tag>
        <tag>学习笔记</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一言API调用]]></title>
    <url>%2F2018%2F01%2F14%2Fhitokoto%2F</url>
    <content type="text"><![CDATA[一言是一个非常棒的一句话服务 关于如何调用一言API到自己的博客中呢?首先可以看一下一言的API的内容：http://hitokoto.cn/api这里提供一个简单的调用js 123456789101112131415161718window.onload=function () &#123; var hitokoto = document.querySelector('.hitokoto'); var from = document.querySelector('.from'); update(); function update() &#123; gethi = new XMLHttpRequest(); gethi.open("GET","https://sslapi.hitokoto.cn/?c=a"); //这里选择类别，详见官方文档 gethi.send(); gethi.onreadystatechange = function () &#123; if (gethi.readyState===4 &amp;&amp; gethi.status===200) &#123; var Hi = JSON.parse(gethi.responseText); hitokoto.innerHTML = Hi.hitokoto; from.innerHTML = "from: &lt;b&gt;" + Hi.from + "&lt;/b&gt;"; //可自定义输出格式 &#125; &#125; &#125;&#125; 接下来可以直接在网页上通过hitokoto和from两个class调用了，例如：1234&lt;div&gt; &lt;p class="hitokoto"&gt;&lt;/p&gt; &lt;p class="from"&gt;&lt;/p&gt;&lt;/div&gt; 如何在Hexo中调用一言呢？很简单。以我的主题next为例。在目录\themes\next\source\js\src（新版next没有src文件夹）下新建hitokoto.js把调用js写进去。如果要经常性的调用，要写在网页中，那么就在\themes\next\layout\_layout.swig的最下面的&lt;/body&gt;前新增一行。 1&lt;script type="text/javascript" src="/js/src/hitokoto.js"&gt;&lt;/script&gt; 如果只在某个网页中使用不必这样，在md中引用javascript即可，引用格式同上面的_layout.swig增加的那行相同。在写文章时在md文件里直接写1234&lt;div&gt; &lt;p class="hitokoto"&gt;&lt;/p&gt; &lt;p class="from"&gt;&lt;/p&gt;&lt;/div&gt; 就可以了。效果如下： 当然，你可以改成任何你喜欢的样子。js代码可以改，html也可以。我感觉这样斜体也不错（参见关于）：123&lt;div&gt; &lt;i class="hitokoto"&gt;&lt;/i&gt;&lt;i class="from"&gt;&lt;/i&gt;&lt;/div&gt; 还有一个带二维码的hitokoto.html值得注意的是，这种调用方法只能同时调用一次。如有需要可以自己改一下代码。参考文章：一言Hitokoto API 调用指南]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提问的艺术]]></title>
    <url>%2F2018%2F01%2F10%2Fhow-to-ask%2F</url>
    <content type="text"><![CDATA[提问之前在通过电邮、新闻组或者聊天室提出技术问题前，检查你有没有做到： 1.通读手册，试着自己找答案。2.在FAQ里找答案（一份维护得好的FAQ可以包罗万象:）。3.在网上搜索（个人推荐google~~~）。4.向你身边精于此道的朋友打听。 当你提出问题的时候，首先要说明在此之前你干了些什么；这将有助于树立你的形象：你不是一个妄图不劳而获的乞讨者，不愿浪费别人的时间。如果提问者能从答案中学到东西，我们更乐于回答他的问题。 周全的思考，准备好你的问题，草率的发问只能得到草率的回答，或者根本得不到任何答案。越表现出在寻求帮助前为解决问题付出的努力，你越能得到实质性的帮助。 小心别问错了问题。如果你的问题基于错误的假设，普通黑客（J. Random Hacker）通常会用无意义的字面解释来答复你，心里想着“蠢问题…”，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。 决不要自以为够资格得到答案，你没这种资格。毕竟你没有为这种服务支付任何报酬。你要自己去“挣”回一个答案，靠提出一个有内涵的，有趣的，有思维激励作用的问题–一个对社区的经验有潜在贡献的问题，而不仅仅是被动的从他人处索要知识–去挣到这个答案。 另一方面，表明你愿意在找答案的过程中做点什么，是一个非常好的开端。“谁能给点提示？”、“我这个例子里缺了什么？”以及“我应该检查什么地方？”比“请把确切的过程贴出来”更容易得到答复。因为你显得只要有人指点正确的方向，你就有完成它的能力和决心。 怎样提问-谨慎选择论坛 小心选择提问的场合。如果象下面描述的那样，你很可能被忽略掉或者被看作失败者： 1.在风马牛不相及的论坛贴出你的问题2.在探讨高级技巧的论坛张贴非常初级的问题；反之亦然3.在太多的不同新闻组交叉张贴 -用辞贴切，语法正确，拼写无误 我们从经验中发现，粗心的写作者通常也是马虎的思考者（我敢打包票）。 回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。 正确的拼写，标点符号和大小写很重要。 更一般的说，如果你的提问写得象个半文盲，你很有可能被忽视。 如果你在使用非母语的论坛提问，你可以犯点拼写和语法上的小错–但决不能在思考上马虎（没错，我们能弄清两者的分别）。 -使用含义丰富，描述准确的标题 在邮件列表或者新闻组中，大约50字以内的主题标题是抓住资深专家注意力的黄金时机。别用喋喋不休的“帮帮忙”（更别说“救命啊！！！！！”这样让人反感的话）来浪费这个机会。不要妄想用你的痛苦程度来打动我们， 别用空格代替问题的描述，哪怕是极其简短的描述。 蠢问题： 救命啊！我的膝上机不能正常显示了！ 聪明问题：XFree86 4.1下鼠标光标变形，Fooware MV1005的显示芯片。 如果你在回复中提出问题，记得要修改内容标题，表明里面有一个问题。一个看起来象“Re：测试”或者“Re：新bug”的问题很难引起足够重视。另外，引用并删减前文的内容，给新来的读者留下线索。 -精确描述，信息量大 1.谨慎明确的描述症状。2.提供问题发生的环境（机器配置、操作系统、应用程序以及别的什么）。3.说明你在提问前是怎样去研究和理解这个问题的。4.说明你在提问前采取了什么步骤去解决它。5.罗列最近做过什么可能有影响的硬件、软件变更。 尽量想象一个黑客会怎样反问你，在提问的时候预先给他答案。 Simon Tatham写过一篇名为《如何有效的报告Bug》的出色短文。强力推荐你也读一读。 -话不在多 你需要提供精确有效的信息。这并不是要求你简单的把成吨的出错代码或者数据完全转储摘录到你的提问中。如果你有庞大而复杂的测试条件，尽量把它剪裁得越小越好。 这样做的用处至少有三点。第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；第二，简化问题使你得到有用答案的机会增加；第三，在提炼你的bug报告的过程中，也许你自己就能找出问题所在或作出更正。 -只说症状，不说猜想 告诉黑客们你认为问题是怎样引起的没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，不要加进你自己的理解和推论。让黑客们来诊断吧。 蠢问题： 我在内核编译中一次又一次遇到SIG11错误，我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？ 聪明问题： 我自制的一套K6/233系统，主板是FIC-PA2007（VIA Apollo VP2芯片组），256MB Corsair PC133 SDRAM，在内核编译中频频产生SIG11错误，从开机20分钟以后就有这种情况，开机前20分钟内从没发生过。重启也没有用，但是关机一晚上就又能工作20分钟。所有内存都换过了，没有效果。相关部分的典型编译记录如下…。 -按时间顺序列出症状 对找出问题最有帮助的线索，往往就是问题发生前的一系列操作，因此，你的说明应该包含操作步骤，以及电脑的反应，直到问题产生。 如果你的说明很长（超过四个段落），在开头简述问题会有所帮助，接下来按时间顺序详述。这样黑客们就知道该在你的说明中找什么。 -明白你想问什么 漫无边际的提问近乎无休无止的时间黑洞。最能给你有用答案的人也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞不太感冒，因此也可以说他们对漫无边际的提问不大感冒。 如果你明确表述需要回答者做什么（提供建议，发送一段代码，检查你的补丁或是别的），就最有可能得到有用的答案。这会定出一个时间和精力的上限，便于回答者集中精力来帮你，这很奏效。要理解专家们生活的世界，要把专业技能想象为充裕的资源，而回复的时间则是贫乏的资源。解决你的问题需要的时间越少，越能从忙碌的专家口中掏出答案。 因此，优化问题的结构，尽量减少专家们解决它所需要的时间，会有很大的帮助–这通常和简化问题有所区别。因此，问“我想更好的理解X，能给点提示吗？”通常比问“你能解释一下X吗？”更好。如果你的代码不能工作，问问它有什么地方不对，比要求别人替你修改要明智得多。 -别问应该自己解决的问题 黑客们总是善于分辨哪些问题应该由你自己解决；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由你来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。 -去除无意义的疑问 别用无意义的话结束提问，例如“有人能帮我吗？”或者“有答案吗？”。首先：如果你对问题的描述不很合适，这样问更是画蛇添足。其次：由于这样问是画蛇添足，黑客们会很厌烦你–而且通常会用逻辑上正确的回答来表示他们的蔑视，例如：“没错，有人能帮你”或者“不，没答案”。 -谦逊绝没有害处，而且常帮大忙 彬彬有礼，多用“请”和“先道个谢了”。让大家都知道你对他们花费时间义务提供帮助心存感激。然而，如果你有很多问题无法解决，礼貌将会增加你得到有用答案的机会。 （我们注意到，自从本指南发布后，从资深黑客处得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得“先谢了”的言外之意是过后就不会再感谢任何人了。我们的建议是：都道谢。） -问题解决后，加个简短说明 问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个补充说明。补充说明不必很长或是很深入；简单的一句“你好，原来是网线出了问题！谢谢大家–Bill”比什么也不说要强。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇学术论文更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。除了表示礼貌和反馈信息以外，这种补充有助于他人在邮件列表/新闻组/论坛中搜索对你有过帮助的完整解决方案，这可能对他们也很有用。最后（至少？），这种补充有助于所有提供过帮助的人从中得到满足感。如果你自己不是老手或者黑客，那就相信我们，这种感觉对于那些你向他们求助的导师或者专家而言，是非常重要的。问题久拖未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次贴出新问题时尝到甜头。 -还是不懂 如果你不是很理解答案，别立刻要求对方解释。象你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），去理解它。如果你真的需要对方解释，记得表现出你已经学到了点什么。比方说，如果我回答你：“看来似乎是zEntry被阻塞了；你应该先清除它。”，然后：一个很糟的后续问题： “zEntry是什么？” 聪明的问法应该是这样：“哦~~~我看过帮助了但是只有-z和-p两个参数中提到了zEntry而且还都没有清楚的解释:&lt;你是指这两个中的哪一个吗？还是我看漏了什么？” 三思而后问以下是几个经典蠢问题，以及黑客在拒绝回答时的心中所想： 问题：我能在哪找到X程序？问题：我的程序/配置/SQL申明没有用问题：我的Windows有问题，你能帮我吗？问题：我在安装Linux（或者X）时有问题，你能帮我吗？问题：我怎么才能破解root帐号/窃取OP特权/读别人的邮件呢？ 提问：我能在哪找到X程序？回答：就在我找到它的地方啊蠢货–搜索引擎的那一头。天呐！还有人不会用Google吗？ 提问：我的程序（配置、SQL申明）没有用回答：这不算是问题吧，我对找出你的真正问题没兴趣–如果要我问你二十个问题才找得出来的话–我有更有意思的事要做呢。 在看到这类问题的时候，我的反应通常不外如下三种： 1.你还有什么要补充的吗？2.真糟糕，希望你能搞定。3.这跟我有什么鸟相关？ 提问：我的Windows有问题，你能帮我吗？回答：能啊，扔掉萎软的垃圾，换Linux吧。 提问：我在安装Linux（或者X）时有问题，你能帮我吗？回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的Linux用户组寻求手把手的指导吧（你能在这儿找到用户组的清单）。 提问：我怎么才能破解root帐号/窃取OP特权/读别人的邮件呢？回答：想要这样做，说明你是个卑鄙小人；想找个黑客帮你，说明你是个ΘΘΘΘ！ 好问题，坏问题最后，我举一些例子来说明，怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。 蠢问题：我可以在哪儿找到关于Foonly Flurbamatic的资料？ //这种问法无非想得到“STFW”这样的回答。 聪明问题：我用Google搜索过“Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？ //这个问题已经STFW过了，看起来他真的遇到了麻烦。 蠢问题：我从FOO项目找来的源码没法编译。它怎么这么烂？ //他觉得都是别人的错，这个傲慢自大的家伙 聪明问题：FOO项目代码在Nulix 6.2版下无法编译通过。我读过了FAQ，但里面没有提到跟Nulix有关的问题。这是我编译过程的记录，我有什么做得不对的地方吗？ //他讲明了环境，也读过了FAQ，还指明了错误，并且他没有把问题的责任推到别人头上，这个家伙值得留意。 蠢问题：我的主板有问题了，谁来帮我？ //普通黑客对这类问题的回答通常是：“好的，还要帮你拍拍背和换尿布吗？” ，然后按下删除键。 聪明问题：我在S2464主板上试过了X、Y和Z，但没什么作用，我又试了A、B和C。请注意当我尝试C时的奇怪现象。显然边带传输中出现了收缩，但结果出人意料。在多处理器主板上引起边带泄漏的通常原因是什么？谁有好主意接下来我该做些什么测试才能找出问题？ //这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。 在最后一个问题中，注意“告诉我答案”和“给我启示，指出我还应该做什么诊断工作”之间微妙而又重要的区别。事实上，后一个问题源自于2001年8月在Linux内核邮件列表上的一个真实的提问。我（Eric）就是那个提出问题的人。我在Tyan S2464主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决那一问题的重要信息。 通过我的提问方法，我给了大家值得玩味的东西；我让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，邀请他们与我共同探讨。我告诉他们我所走过的弯路，以避免他们再浪费时间，这是一种对他人时间价值的尊重。后来，当我向每个人表示感谢，并且赞赏这套程序（指邮件列表中的讨论 –译者注）运作得非常出色的时候，一个Linux内核邮件列（lkml）成员表示，问题得到解决并非由于我是这个列表中的“名人”，而是因为我用了正确的方式来提问。我们黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我象个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，给编写这个指南的人一些指导。 找不到答案怎么办如果仍得不到答案，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。 总的说来，简单的重复张贴问题是个很糟的想法。这将被视为无意义的喧闹。 你可以通过其它渠道获得帮助，这些渠道通常更适合初学者的需要。有许多网上的以及本地的用户组，由狂热的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。 另外，你可以向很多商业公司寻求帮助，不论公司大还是小（Red Hat和LinuxCare就是两个最常见的例子）。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了–完全可能如此– 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。 对大众化的软件，就象Linux之类而言，每个开发者至少会有上万名用户。根本不可能由一个人来处理来自上万名用户的求助电话。要知道，即使你要为帮助付费，同你必须购买同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开放源代码软件要高得多，且内容也不那么丰富）。 如何有效地报告Bug引言 为公众写过软件的人，大概都收到过很拙劣的bug（计算机程序代码中的错误或程序运行时的瑕疵——译者注）报告，例如： 在报告中说“不好用”；所报告内容毫无意义；在报告中用户没有提供足够的信息；在报告中提供了虚假信息；所报告的问题是由于用户的过失而产生的；所报告的问题是由于其他程序的错误而产生的；所报告的问题是由于网络错误而产生的； 这便是为什么“技术支持”被认为是一件可怕的工作，因为有拙劣的bug报告需要处理。然而并不是所有的bug报告都令人生厌：我在业余时间维护自由软件，有时我会收到非常清晰、有帮助并且内容丰富的bug报告。 在这里我会尽力阐明如何写一个好的bug报告。我非常希望每一个人在报告bug之前都读一下这篇短文，当然我也希望用户在给我报告bug之前已经读过这篇文章。 简单地说，报告bug的目的是为了让程序员看到程序的错误。您可以亲自示范，也可以给出能导致程序出错的、详尽的操作步骤。如果程序出错了，程序员会收集额外的信息直到找到错误的原因；如果程序没有出错，那么他们会请您继续关注这个问题，收集相关的信息。 在bug报告里，要设法搞清什么是事实（例如：“我在电脑旁”和“XX出现了”）什么是推测（例如：“我想问题可能是出在……”）。如果愿意的话，您可以省去推测，但是千万别省略事实。 当您报告bug的时候（既然您已经这么做了），一定是希望bug得到及时修正。所以此时针对程序员的任何过激或亵渎的言语（甚至谩骂）都是与事无补的 ——因为这可能是程序员的错误，也有可能是您的错误，也许您有权对他们发火，但是如果您能多提供一些有用的信息（而不是激愤之词）或许bug会被更快的修正。除此以外，请记住：如果是免费软件，作者提供给我们已经是出于好心，所以要是太多的人对他们无礼，他们可能就要“收起”这份好心了。 “程序不好用” 程序员不是弱智：如果程序一点都不好用，他们不可能不知道。他们不知道一定是因为程序在他们看来工作得很正常。所以，或者是您作过一些与他们不同的操作，或者是您的环境与他们不同。他们需要信息，报告bug也是为了提供信息。信息总是越多越好。 许多程序，特别是自由软件，会公布一个“已知bug列表”。如果您找到的bug在列表里已经有了，那就不必再报告了，但是如果您认为自己掌握的信息比列表中的丰富，那无论如何也要与程序员联系。您提供的信息可能会使他们更简单地修复bug。 本文中提到的都是一些指导方针，没有哪一条是必须恪守的准则。不同的程序员会喜欢不同形式的bug报告。如果程序附带了一套报告bug的准则，一定要读。如果它与本文中提到的规则相抵触，那么请以它为准。 如果您不是报告bug，而是寻求帮助，您应该说明您曾经到哪里找过答案，（例如：我看了第四章和第五章的第二节，但我找不到解决的办法。）这会使程序员了解用户喜欢到哪里去找答案，从而使程序员把帮助文档做得更容易使用。 “演示给我看” 报告bug的最好的方法之一是“演示”给程序员看。让程序员站在电脑前，运行他们的程序，指出程序的错误。让他们看着您启动电脑、运行程序、如何进行操作以及程序对您的输入有何反应。 他们对自己写的软件了如指掌，他们知道哪些地方不会出问题，而哪些地方最可能出问题。他们本能地知道应该注意什么。在程序真的出错之前，他们可能已经注意到某些地方不对劲，这些都会给他们一些线索。他们会观察程序测试中的每一个细节，并且选出他们认为有用的信息。 这些可能还不够。也许他们觉得还需要更多的信息，会请您重复刚才的操作。他们可能在这期间需要与您交流一下，以便在他们需要的时候让bug重新出现。他们可能会改变一些操作，看看这个错误的产生是个别问题还是相关的一类问题。如果您不走运，他们可能需要坐下来，拿出一堆开发工具，花上几个小时研究。但是最重要的是在程序出错的时候让程序员在电脑旁。一旦他们看到了问题，他们通常会找到原因并开始试着修改。 “告诉我该怎么做” 如今是网络时代，是信息交流的时代。我可以点一下鼠标把自己的程序送到俄罗斯的某个朋友那里，当然他也可以用同样简单的方法给我一些建议。但是如果我的程序出了什么问题，我不可能在他旁边。“演示”是很好的办法，但是常常做不到。 如果您必须报告bug，而此时程序员又不在您身边，那么您就要想办法让bug重现在他们面前。当他们亲眼看到错误时，就能够进行处理了。 确切地告诉程序员您做了些什么。如果是一个图形界面程序，告诉他们您按了哪个按钮，依照什么顺序按的。如果是一个命令行程序，精确的告诉他们您键入了什么命令。您应该尽可能详细地提供您所键入的命令和程序的反应。 把您能想到的所有的输入方式都告诉程序员，如果程序要读取一个文件，您可能需要发一个文件的拷贝给他们。如果程序需要通过网络与另一台电脑通讯，您或许不能把那台电脑复制过去，但至少可以说一下电脑的类型和安装了哪些软件（如果可以的话）。 “哪儿出错了？在我看来一切正常哦！” 如果您给了程序员一长串输入和指令，他们执行以后没有出现错误，那是因为您没有给他们足够的信息，可能错误不是在每台计算机上都出现，您的系统可能和他们的在某些地方不一样。有时候程序的行为可能和您预想的不一样，这也许是误会，但是您会认为程序出错了，程序员却认为这是对的。 同样也要描述发生了什么。精确的描述您看到了什么。告诉他们为什么您觉得自己所看到的是错误的，最好再告诉他们，您认为自己应该看到什么。如果您只是说：“程序出错了”，那您很可能漏掉了非常重要的信息。 如果您看到了错误消息，一定要仔细、准确的告诉程序员，它们很重要。在这种情况下，程序员只要修正错误，而不用去找错误。他们需要知道是什么出问题了，系统所报的错误消息正好帮助了他们。如果您没有更好的方法记住这些消息，就把它们写下来。只报告“程序出了一个错”是毫无意义的，除非您把错误消息一块报上来。 特殊情况下，如果有错误消息号，一定要把这些号码告诉程序员。不要以为您看不出任何意义，它就没有意义。错误消息号包含了能被程序员读懂的各种信息，并且很有可能包含重要的线索。给错误消息编号是因为用语言描述计算机错误常常令人费解。用这种方式告诉您错误的所在是一个最好的办法。 在这种情形下，程序员的排错工作会十分高效。他们不知道发生了什么，也不可能到现场去观察，所以他们一直在搜寻有价值的线索。错误消息、错误消息号以及一些莫名其妙的延迟，都是很重要的线索，就像办案时的指纹一样重要，保存好。 如果您使用UNIX系统，程序可能会产生一个内核输出（core dump）。内核输出是特别有用的线索来源，别扔了它们。另一方面，大多数程序员不喜欢收到含有大量内核输出文件的EMAIL，所以在发邮件之前最好先问一下。还有一点要注意：内核输出文件记录了完整的程序状态，也就是说任何秘密（可能当时程序正在处理一些私人信息或秘密数据）都可能包含在内核输出文件里。 出了问题之后，我做了……” 当一个错误或bug发生的时候，您可能会做许多事情。但是大多数人会使事情变的更糟。我的一个朋友在学校里误删了她所有的Word文件，在找人帮忙之前她重装了Word，又运行了一遍碎片整理程序，这些操作对于恢复文件是毫无益处的，因为这些操作搞乱了磁盘的文件区块。恐怕在这个世界上没有一种反删除软件能恢复她的文件了。如果她不做任何操作，或许还有一线希望。 这种人仿佛一只被逼到墙角的鼬（黄鼠狼、紫貂一类的动物——译者注）：背靠墙壁，面对死亡的降临奋起反扑，疯狂攻击。他们认为做点什么总比什么都不做强。然而这些在处理计算机软件问题时并不适用。不要做鼬，做一只羚羊。当一只羚羊面对料想不到的情况或受到惊吓时，它会一动不动，是为了不吸引任何注意，与此同时也在思考解决问题的最好办法（如果羚羊有一条技术支持热线，此时占线。）。然后，一旦它找到了最安全的行动方案，它便去做。 当程序出毛病的时候，立刻停止正在做的任何操作。不要按任何按钮。仔细地看一下屏幕，注意那些不正常的地方，记住它或者写下来。然后慎重地点击 “确定” 或“取消”，选择一个最安全的。学着养成一种条件反射——一旦电脑出了问题，先不要动。要想摆脱这个问题，关掉受影响的程序或者重新启动计算机都不好，一个解决问题的好办法是让问题再次产生。程序员们喜欢可以被重现的问题，快乐的程序员可以更快而且更有效率的修复bug。 “我想粒子的跃迁与错误的极化有关” 并不只是非专业的用户才会写出拙劣的bug报告，我见过一些非常差的bug报告出自程序员之手，有些还是非常优秀的程序员。 有一次我与另一个程序员一起工作，他一直在找代码中的bug，他常常遇到一个bug，但是不会解决，于是就叫我帮忙。“出什么毛病了？”我问。而他的回答却总是一些关于bug的意见。如果他的观点正确，那的确是一件好事。这意味着他已经完成了工作的一半，并且我们可以一起完成另一半工作。这是有效率并有用的。 但事实上他常常是错的。这就会使我们花上半个小时在原本正确的代码里来回寻找错误，而实际上问题出在别的地方。我敢肯定他不会对医生这么做。“大夫，我得了Hydroyoyodyne（真是怪病——译者），给我开个方子”，人们知道不该对一位医生说这些。您描述一下症状，哪个地方不舒服，哪里疼、起皮疹、发烧……让医生诊断您得了什么病，应该怎样治疗。否则医生会把您当做疑心病或精神病患者打发了，这似乎没什么不对。 做程序员也是一样。即便您自己的“诊断”有时真的有帮助，也要只说“症状”。“诊断”是可说可不说的，但是“症状”一定要说。同样，在bug报告里面附上一份针对bug而做出修改的源代码是有用处的，但它并不能替代bug报告本身。 如果程序员向您询问额外的信息，千万别应付。曾经有一个人向我报告bug，我让他试一个命令，我知道这个命令不好用，但我是要看看程序会返回一个什么错误（这是很重要的线索）。但是这位老兄根本就没试，他在回复中说“那肯定不好用”，于是我又花了好些时间才说服他试了一下那个命令。 多动动脑筋对程序员是有帮助的。即使您的推断是错误的，程序员也应该感谢您，您的尝试使他们的工作变的更简单。不过千万别忘了报告“症状”，否则只会使事情变得更糟。 “真是奇怪，刚才还不好用，怎么现在又好了？” “间歇性错误”着实让程序员发愁。相比之下，进行一系列简单的操作便能导致错误发生的问题是简单的。程序员可以在一个便于观察的条件下重复那些操作，观察每一个细节。太多的问题在这种情况下不能解决，例如：程序每星期出一次错，或者偶然出一次错，或者在程序员面前从不出错（程序员一离开就出错。——译者）。当然还有就是程序的截止日期到了，那肯定要出错。 大多数“间歇性错误”并不是真正的“间歇”。其中的大多数错误与某些地方是有联系的。有一些错误可能是内存泄漏产生的，有一些可能是别的程序在不恰当的时候修改某个重要文件造成的，还有一些可能发生在每一个小时的前半个小时中（我确实遇到过这种事情）。 同样，如果您能使bug重现，而程序员不能，那很有可能是他们的计算机和您的计算机在某些地方是不同的，这种不同引起了问题。我曾写过一个程序，它的窗口可以蜷缩成一个小球停在屏幕的左上角，它在别的计算机上只能在800×600解析度工作，但是在我的机器上却可以在1024×768工作。 程序员想要了解任何与您发现的问题相关的事情。有可能的话您到另一台机器上试试，多试几次，两次，三次，看看问题是不是经常发生。如果问题出现在您进行了一系列操作之后，不是您想让它出现它就会出现，这就有可能是长时间的运行或处理大文件所导致的错误。程序崩溃的时候，您要尽可能的记住您都做了些什么，并且如果您看到任何图形,也别忘了提一下。您提供的任何事情都是有帮助的。即使只是概括性的描述（例如：当后台有EMACS运行时，程序常常出错），这虽然不能提供导致问题的直接线索，但是可能帮助程序员重现问题。 最重要的是：程序员想要确定他们正在处理的是一个真正的“间歇性错误”呢，还是一个在另一类特定的计算机上才出现的错误。他们想知道有关您计算机的许多细节，以便了解您的机器与他们的有什么不同。有许多细节都依仗特定的程序，但是有一件东西您一定要提供——版本号。程序的版本、操作系统的版本以及与问题有关的程序的版本。 “我把磁盘装进了我的Windows……” 表意清楚在一份bug报告里是最基本的要求。如果程序员不知道您说的是什么意思，那您就跟没说一样。我收到的bug报告来自世界各地，有许多是来自非英语国家，他们通常为自己的英文不好而表示歉意。总的来说，这些用户发来的bug报告通常是清晰而且有用的。几乎所有不清晰的bug报告都是来自母语是英语的人，他们总是以为只要自己随便说说，程序员就能明白。 精确： 如果做相同的事情有两种方法，请说明您用的是哪一种。例如：“我选择了‘载入’”，可能意味着“我用鼠标点击‘载入’”或“我按下了‘ALT+L’”，说清楚您用了哪种方法，有时候这也有关系。 详细： 信息宁多毋少！如果您说了很多，程序员可以略去一部分，可是如果您说的太少，他们就不得不回过头再去问您一些问题。有一次我收到了一份bug报告只有一句话，每一次我问他更多事情时，他每次的回复都是一句话，于是我花了几个星期的时间才得到了有用的信息。 谨慎使用代词： 诸如“它”，“窗体”这些词，当它们指代不清晰的时候不要用。来看看这句话：“我运行了FooApp，它弹出一个警告窗口，我试着关掉它，它就崩溃了。”这种表述并不清晰，用户究竟关掉了哪个窗口？是警告窗口还是整个FooApp程序？您可以这样说，“我运行FooApp程序时弹出一个警告窗口，我试着关闭警告窗口，FooApp崩溃了。”这样虽然罗嗦点，但是很清晰不容易产生误解。 检查： 重新读一遍您写的bug报告，您觉得它是否清晰？如果您列出了一系列能导致程序出错的操作，那么照着做一遍，看看您是不是漏写了一步。 小结： bug报告的首要目的是让程序员亲眼看到错误。如果您不能亲自做给他们看，给他们能使程序出错的详细的操作步骤。 如果首要目的不能达成，程序员不能看到程序出错。这就需要bug报告的第二个目的来描述程序的什么地方出毛病了。详细的描述每一件事情：您看到了什么，您想看到什么，把错误消息记下来，尤其是“错误消息号”。 当您的计算机做了什么您料想不到的事，不要动！在您平静下来之前什么都别做。不要做您认为不安全的事。 尽量试着自己“诊断”程序出错的原因（如果您认为自己可以的话）。即使做出了“诊断”，您仍然应该报告“症状”。 如果程序员需要，请准备好额外的信息。如果他们不需要，就不会问您要。他们不会故意为难自己。您手头上一定要有程序的版本号，它很可能是必需品。 表述清楚，确保您的意思不能被曲解。 总的来说，最重要的是要做到精确。程序员喜欢精确。 本文来源Copyright(C) 2001 by Eric S. Raymond中文版Copyleft 2001 by D.H.Grand(nOBODY/Ginux)英文版：http://www.tuxedo.org/~esr/faqs/smart-questions.html感谢Eric的耐心指点和同意，本文才得以完成并发布本指南英文版版权为Eric Steven Raymond 所有 中文版版权由D.H.Grand[nOBODY/Ginux]所有 附带一个好玩的小东西CNM你不会百度吗？(参数为q)]]></content>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github搭建Hexo博客]]></title>
    <url>%2F2017%2F12%2F30%2FGithubHexo%2F</url>
    <content type="text"><![CDATA[开始之前为什么要用Github搭建Hexo的博客呢？首先，省钱！作为一个学生狗，服务器支出是一笔不少的费用，虽然我现在有一台腾讯云1元的服务器，但是这台服务器还有别的用途。用Github搭建网站完全免费。除此之外，Hexo生成的是静态网站，托管在Github上，只要不是有人黑了你的Github帐号，你的网站就很安全。于是我背叛了worldpress转到了Hexo+Github上 准备 github建立Repository，名字为你的名字.github.io（如wwillv.github.io） 电脑上安装Git和Node.js(国内上不去可以用Node.js中文网) 安装 在你准备建立Hexo的位置上建立一个文件夹，如blog，cd进入该目录npm install -g hexo安装hexo 输入hexo init初始化hexo 输入hexo g(或hexo generate)生成静态页面 输入hexo s(或hexo server)启动本地服务浏览器打开localhost:4000如果你能看到这个界面说明你的hexo搭建已基本成功 此时你的hexo本地配置已基本完成，可以上传github了，但为了方便我将在本地顺便将主题和插件也一并配置结束，你可以跳过这一步骤直接到上传Github去 配置主题 主题选择，网上有很多hexo的主题，github上也有很多，我选择的是Next 大多数的主题的页面都有详细的配置教程，以Next为例 cd进入themes目录，clone仓库到next文件夹git clone https://github.com/iissnan/hexo-theme-next next 在 hexo 根目录下 的配置文件_config.yml里设置主题theme: next 根据自己需要可以继续自定义主题，next主题可以参考这篇文章 运行hexo clean，运行hexo g后运行hexo s，浏览器打开http://localhost:4000/可以看到自己的新主题的样子了 上传Github 回到主目录，安装hexo-deployer-gitnpm install hexo-deployer-git 修改blog文件夹（博客根目录）下的_config.yml，最下面的deploy:修改为如下格式 1234deploy: type: git repo: https://github.com/WWILLV/wwillv.github.io.git（这里是你的仓库地址，后面要加.git） branch: master hexo d（或hexo deploy）将网站上传至github 网站已建立完毕，访问你的名字.github.io（如wwillv.github.io）即可查看 网站备份由于hexo上传到Github上是生成的网站，源文件是不会上传的，换电脑后再移动文件很麻烦，这里推荐一个自动备份网站到Github的工具hexo-git-backup,可按照README的介绍进行安装 npm install hexo-git-backup --save安装hexo-git-backup 修改根目录的_config.yml，加入如下内容： 12345backup: type: git theme: next,landscape,xxx repository: github: git@github.com:xxx/xxx.git,branchName hexo b备份文件 获取备份12git clone git@github.com:username/username.github.io.gitgit checkout branchname 绑定域名 注册域名，腾讯云，阿里云（万网），GoDaddy什么的都可以，域名注册商有很多 一般域名注册都提供域名的解析，解析前ping一下自己的github.io ping wwillv.github.io如图所示我的IP是151.101.229.147 已腾讯云的解析为例，添加如下2条记录，1条A记录和1条CHAME记录 在Github的仓库的设置Custom domain里填入自己的域名（不建议）在Custom domain设置域名后会发现每次上传后域名都会失效，这是因为设置Custom domain会生成一个CNAME文件，上传后这个文件会被删除，所以可以在\source目录下新建一个CNAME文件。Windows不能直接生成没有后缀的文件，可以先生成一个再用move命令重命名，但这样比较麻烦。如果有touch的话可以直接在目录下执行touch CNAME命令就可以生成了。文件内只需写一行域名即可，如willv.cn。 浏览器输入自己的域名，刷新一会儿就出来了 开始第一篇文章hexo new &quot;title&quot;（或hexo n &quot;title&quot;）新建一篇文章，也可以在\source\_posts新建一个.md文件。hexo使用markdown语法，文章也是md格式。与平时的富文本的博客不同，写作需要遵循markdown的语法。删除文章直接删除对应的.md文件后hexo g重新生成一下即可。 常用hexo命令 hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 命令缩写 hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令： hexo s -g #生成并本地预览hexo d -g #生成并上传]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
</search>
